{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"YAMTL","text":"<p>Yet Another Model Transformation Language (YAMTL) is an expressive model-to-model transformation language that is offered as an internal domain-specific language (DSL) of JVM languages, including Java, Xtend, Groovy and Kotlin.</p> <p>YAMTL is available as an IDE-agnostic Java dependency that augments the Java ecosystem with model analysis and model transformation capabilities that are not yet available in the latest version of Java. YAMTL transformations can be developed, debugged, and analyzed using the preferred Java IDE of choice and they can build upon existing Java dependencies to automate complex tasks. YAMTL operates on models defined with the Eclipse Modeling Framework.</p> <p>YAMTL was found to be the fastest incremental model transformation tool, in general, for dealing with complex transformations between AADL models according to an independent industrial case study<sup>1</sup>. </p> <ol> <li> <p>Hana Mkaouar, Dominique Blouin, Etienne Borde: A benchmark of incremental model transformation tools based on an industrial case study with AADL. Softw. Syst. Model. 22(1): 175-201 (2023)\u00a0\u21a9</p> </li> </ol>"},{"location":"contact-us.html","title":"Contact Us","text":"<p>If you have questions or suggestions please contact us at yet.another.model.trafo.lang@gmail.com.</p>"},{"location":"getting-started.html","title":"Getting Started","text":""},{"location":"getting-started.html#what-you-will-do","title":"What you will do","text":"<p>Create and set up a YAMTL project (without models and metamodels) that is ready for model transformations in an IDE of your choice.</p>"},{"location":"getting-started.html#what-you-need","title":"What you need","text":"<ul> <li>An IDE (e.g. Eclipse, VSCode or IntelliJ)</li> <li>Java 17 or later (Minimum requirement)</li> <li>Gradle 8.0+ (Minimum requirement)</li> <li>Groovy plugin installed in your IDE (see Choosing an IDE to install it)</li> <li>Time to complete: about 10 minutes</li> </ul>"},{"location":"getting-started.html#walkthrough","title":"Walkthrough","text":"<p>First, you need to create a Gradle project in your IDE. Here, are the ways to do so in some common IDEs:</p> <p>Eclipse: Create a new <code>Other</code> project. Then search for <code>Gradle Project</code>, choose a suitable starter project name, and hit <code>Finish</code>.</p> <p>IntelliJ: Go <code>File \u2192 New \u2192 Project... \u2192 New Project</code>. Choose the language as <code>Groovy</code>, build system as <code>Gradle</code>, JDK as 17 or higher, and Gradle DSL as <code>Groovy</code>. </p> <p>VSCode: Do <code>Shift+Cmd+P</code> or <code>Ctrl+Shift+P</code> to open editor commands. Search and click on the <code>Gradle project</code> (may require <code>Gradle for Java</code> extension to be installed). Do <code>Build script DSL as Groovy \u2192 New Project Name</code>. </p> <p>YAMTL uses Gradle as build automation tool and can be executed from Java-SE 17. To add YAMTL to your project you must configure the Gradle build script (<code>build.gradle</code>) of your project. Add the Groovy plugin (at the top of the <code>build.gradle</code> file): <pre><code>plugins {\n    id \"groovy\"\n}\n</code></pre></p> <p>Add the following repositories: <pre><code>repositories {\n    maven{ url 'https://github.com/yamtl/yamtl.github.io/raw/master/mvn-repo/snapshot-repo' }\n    mavenCentral()\n}\n</code></pre></p> <p>Then declare the dependencies (EMF dependencies are optional but since many metamodels use EMF format, it is advised you include it): <pre><code>dependencies {\n    // YAMTL dependencies\n    implementation \"yamtl:yamtl:${yamtlVersion}\"\n\n    implementation \"org.apache.groovy:groovy-all:${groovyAllVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore:${ecoreVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore.xmi:${ecoreXmiVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore.change:${ecoreChangeVersion}\"\n    implementation \"org.eclipse.xtend:org.eclipse.xtend.core:${xtendVersion}\"\n    implementation \"org.springframework.boot:spring-boot-starter-aop:${springAopVersion}\"\n    implementation \"org.aspectj:org.aspectjweaver:${aspectJVersion}\"\n}\n</code></pre></p> <p>The latest versions of the dependencies are defined in the <code>build.gradle</code> file can be below:</p> <ul> <li>Latest <code>${yamtlVersion}</code> can be found at yamtl.github.io (release notes).</li> <li>Find the latest <code>${groovyAllVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreXmiVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreChangeVersion}</code> on Maven Central</li> <li>Find the latest <code>${xtendVersion}</code> on Maven Central</li> <li>Find the latest <code>${springAopVersion}</code> on Maven Central</li> <li>Find the latest <code>${aspectJVersion}</code> on Maven Central</li> </ul> <p>Finally, build the project to install the dependencies. </p> <p>You are now ready to use your YAMTL project! Let's now learn how to create a model transformation definition.</p> <ul> <li>First, create a transformation script in <code>src/main/groovy</code> folder (you could also add a package to use multiple scripts) with the  <code>.groovy</code> suffix. Then, import a few YAMTL and EMF libraries:</li> </ul> <pre><code>import static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n</code></pre> <ul> <li>Create a specialization of the <code>YAMTLModule</code> by extending it:</li> </ul> <pre><code>class FirstExample extends YAMTLModule \n</code></pre> <ul> <li>Define a new public method <code>FirstExample</code> and pass the source and target metamodels of <code>EPackage</code> type as parameters (Ecore metamodel files are accessed through <code>EPackage</code>). Note: Depending on your case, you may have the same source and target metamodels so you can just pass one parameter.</li> </ul> <pre><code>public FirstExample(EPackage sourcePk, EPackage targetPk)\n</code></pre> <p>OR, if both source and target metamodels are the same:</p> <pre><code>public FirstExample(EPackage metamodelPk)\n</code></pre> <ul> <li>To enable EMF functionality to the YAMTL module, initialize an EMF extension:</li> </ul> <pre><code>YAMTLGroovyExtensions_dynamicEMF.init(this)\n</code></pre> <ul> <li>Within the constructor, a <code>header()</code> is required to define the signature of the transformation: declaration of input and output models. <code>.in()</code> clause defines the characteristics of the input model, where the first parameter is the model's name in quotation marks <code>\"\"</code> and the second parameter is the metamodel to which the input model conforms. The same applies to the output model definition within the <code>.out()</code> clause. </li> </ul> <pre><code>header().in(\"in\", sourcePk).out(\"out\", targetPk)\n</code></pre> <ul> <li>Next is the <code>ruleStore()</code> which contains a list of rule(s). Each rule has one or more input elements which are transformed to one or more output elements. The concrete syntax for rules is described in the next section.</li> </ul> <pre><code>ruleStore([\n    rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes)\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n])\n</code></pre> <ul> <li>You can also add optional helpers that can perform computations of values during the initialization of the transformation. Helpers are contained as a list within the <code>helperStore()</code> operation.</li> </ul> <pre><code>helperStore([\n    //Helpers\n])\n</code></pre> <p>That is how you can create a YAMTL transformation script. For a better idea of a working MT definition check out this Groovy script for an example project:</p> <pre><code>import static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass FirstExample extends YAMTLModule {\n\n    //In this case, both source and target metamodels are same\n    public FirstExample(EPackage llPk) {\n\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in('in', llPk).out('out', llPk)\n\n        ruleStore([\n            rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes)\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n        ])\n    }\n}\n</code></pre> <p>That's all! Now you know how to create your own YAMTL project and define a model transformation script. To learn how to use rules, see the Language Reference section. Or if you want to learn how to run YAMTL projects and configure models, head over to Examples so you can understand model transformations and special YAMTL operations of varying difficulties.</p>"},{"location":"release-notes.html","title":"Release notes","text":""},{"location":"release-notes.html#102","title":"1.0.2","text":"<p>Operations (both static and contextual) have their parameters included in the execution configuration, allowing them to be accessed within the operation's body.</p>"},{"location":"release-notes.html#100-101","title":"1.0.0-1.0.1","text":"<ul> <li>Version tried and tested since 2018 with reliable support for model-to-model transformations and a Groovy DSL.</li> <li>Support for multimodel transformations:</li> <li>Several in/out models can be declared with a unique domainName.</li> <li>allInstances(domainName, type): the domainName needs to be specified when the transformation is multimodel.</li> </ul>"},{"location":"release-notes.html#0437","title":"0.4.37","text":"<p>FIX: registration of metamodels, removing caching so that they can be updated.</p>"},{"location":"release-notes.html#0435-0436","title":"0.4.35, 0.4.36","text":"<p>Support for loading Ecore metamodels with subpackages.</p>"},{"location":"release-notes.html#0434","title":"0.4.34","text":"<p>Unified interface for handling flexible models: * loading models using <code>loadInputModels</code>  * saving models using <code>saveOutputModels</code> * serializing models using <code>toText</code></p> <p>Added support for YAML.</p>"},{"location":"release-notes.html#0433","title":"0.4.33","text":"<p>Improvement in accessors for semi-structured models (JSON, CSV) in the Groovy dialect. The internal structure of the metamodel is hidden and these can be accessed using <code>.</code> notation as in mainstream programming languages.</p>"},{"location":"release-notes.html#0432","title":"0.4.32","text":"<p>Added programmable evaluation strategies for rules with four new operators: </p> <ul> <li><code>applyOne()</code>: applies one rule to the source model, if a match exists. Returns the match or null.</li> <li><code>applyOne(ruleName)</code>: applies the rule once, if a match exists. Returns the match or null.</li> <li><code>applyAll()</code>: all at once semantics. Find all matches for rules in the ruleStore to the source model. Then applies them. Dependencies between rules are not considered.</li> <li><code>applyAll(ruleName)</code>: all at once for a given rule. Find all matches of a given rule and, then apply them in bulk. Dependencies between different rule applications are not considered.</li> </ul> <p>When the module specifies an in-place transformation, <code>applyOne</code> and <code>applyAll</code> delete the matchPool at the end of the execution.</p> <p>The method <code>YAMTLModule::execute(Runnable)</code> now takes a control flow specification as a <code>Runnable</code> that can indicate the order in which rules must be applied using the operators above and control flow logic in the host GPL of choice.</p>"},{"location":"release-notes.html#0431","title":"0.4.31","text":"<p>Metamodels/models can be loaded from URL via EMF, just by using a URL to the model instead of a file path.</p>"},{"location":"release-notes.html#0427","title":"0.4.27","text":"<p>When an object is modified, the following transformation steps need to be re-evaluated: 1. Transformation steps whose input match involves the object. 2. Transformation steps whose input match involves the object container.</p> <p>The second case is necessary in case the model update invalidates the match in transformation steps of type 1.</p>"},{"location":"release-notes.html#0426","title":"0.4.26","text":"<p>When re-executing trafo steps, those marked as dirty are not re-executed but they are not deleted.</p>"},{"location":"release-notes.html#0425","title":"0.4.25","text":"<p>To enable rules that yield destructive actions in the output model, for example: * undoing a transformation step if the rule match is invalidated (matching semantics); * in-place rule with node destruction (in-place semantics).</p> <p>In those cases, models should be saved to a file using the method <code>YAMTLModule::saveOutputModels(pathList, rootClassNameList)</code>.  Only those root objects (detached) that are instance of root classes (whose names are in <code>rootClassNameList</code>) will be added to the resource.  If the list is empty, all objects will be returned.</p> <p>The method <code>YAMTLModule::saveOutputModels(pathList)</code> calls <code>YAMTLModule::saveOutputModels(pathList, #[])</code>.</p>"},{"location":"release-notes.html#0424","title":"0.4.24","text":"<p>FIX: In incremental execution of model transformation, a source model update may deactivate current tranformation steps and enable the application of one other rule/match.</p>"},{"location":"release-notes.html#0423","title":"0.4.23","text":"<p>Graphical representation of metamodels and models using PlantUML in the class <code>prettyprinting.EMFPrettyPrinter</code>.</p>"},{"location":"release-notes.html#0422","title":"0.4.22","text":"<p>FIX null exception when importing EMF model into untyped model, when applied to UML models.</p>"},{"location":"release-notes.html#0421","title":"0.4.21","text":"<p>FIX allInstances due to a bug inserted with SpringAOP proxies</p>"},{"location":"release-notes.html#0420","title":"0.4.20","text":"<p>FIX analysis of on-the-fly changes: moving objects was not handled correctly.</p>"},{"location":"release-notes.html#0419","title":"0.4.19","text":"<p>FIX <code>allInstances()</code>: it needs to return proxies to objects when using SpringAOP.</p>"},{"location":"release-notes.html#0418","title":"0.4.18","text":"<p>Support for in-place transformations: * FIX initialization of in-place transformations. Rename <code>isSpec</code> to <code>isInplace</code>. * Rule variables (<code>using</code>) can be initialized before <code>globalFilter</code>. * FIX save inOut model</p>"},{"location":"release-notes.html#0417","title":"0.4.17","text":"<p>Renamed <code>.cap()</code> to <code>.toManyCap()</code> in <code>toMany()</code> rules.</p>"},{"location":"release-notes.html#0416","title":"0.4.16","text":"<p>FIX error message when matches are not unique for matched rules. This was only checked in incremental mode.</p>"},{"location":"release-notes.html#0415","title":"0.4.15","text":"<p>A resource factory can now be registered to the YAMTLModule registry allowing loading models using specific parsers. This allows YAMTL to load models from files with a given extension, which have a dedicated parser.</p> <p>UML2 dependencies have been removed. To work with UML2, its resource factory implementation needs to be registered before loading models:</p> <pre><code>def xform = new ClassExtendingYAMTLModule()\nxform.registerResourceFactory(\"uml\", new UMLResourceFactoryImpl())\nxform.loadInputModels([\"in\":\"./path/to/model.uml\"])\n</code></pre>"},{"location":"release-notes.html#0414","title":"0.4.14","text":"<ul> <li>Renamed the static method <code>YAMTLModule::loadMetamodel(fileName)</code> to <code>YAMTLModule:preloadMetamodel(fileName)</code> and this now returns a resource instead of a package.</li> <li>Simplified <code>YAMTLModule::loadMetamodel(fileName, standalone)</code>, which enabled the registration of metamodels in the global EMF registry, in favour of <code>YAMTLModule:loadMetamodel(fileName)</code>, which only registers the metamodel in the EMF registry associated with the specific transformation module instance.</li> <li>Added the YAMTLModule::loadMetamodelResource(Resource) method, which allows for loading a metamodel via its resource. This capability facilitates:</li> <li>Static Preloading: You can preload a metamodel and later load that same metamodel for a specific YAMTLModule instance. This aids in loading models consistently.</li> <li>Dynamic EMF Model Transformations: One application of this configuration arises when there's a need to preload metamodels for transformations dealing with EMF models dynamically (leveraging the EMF reflective API). This results in the generation of output models based on the preloaded output metamodel.</li> <li>Testing: Subsequently, for testing purposes, there might be a need to load the expected output models. It's essential these models use the exact same output metamodel for consistency.</li> </ul>"},{"location":"release-notes.html#0413","title":"0.4.13","text":"<p>Support for UML2 models in the YAMTL registry. UML2 models can now be loaded without having to register the metamodel.</p>"},{"location":"release-notes.html#0412","title":"0.4.12","text":"<p>FIX in YAMTLGroovyExtensions: a getter method was not invoked correctly.</p>"},{"location":"release-notes.html#0410-0411","title":"0.4.10, 0.4.11","text":"<p>Reorganised methods in </p> <ul> <li><code>YAMTLGroovyExtensions</code>: support for calling helpers and lazy rules. This needs to be executed after the module has been loaded.</li> <li><code>YAMTLGroovyExtensions_dynamicEMF</code>: support for parsing the transformation while loading the YAMTL module. It contains support for fetch, and for accessors/mutators since EMF code is not available.</li> </ul>"},{"location":"release-notes.html#049","title":"0.4.9","text":"<p>FIX how Groovy calls contextual operations. It was confusing contextual operations with lazy rules.</p>"},{"location":"release-notes.html#048","title":"0.4.8","text":"<ul> <li>FIX: endWith can be used after an out element.</li> <li>FIX: removing <code>with</code> dependencies in change in 0.3.5 affects model sensitivity. The pattern matcher may reorder the matching of input elements in a way that creates conflicts when evaluating filter expressions. A new flag <code>YAMTLModule::setEnabledMatchingInputElementOrderBySize</code> has been added to enable this implicit order that makes pattern matching aware of the model contents. By default, it is disabled. It can be enabled when it does not affect the evaluation of filters. See documentation for further information.</li> </ul>"},{"location":"release-notes.html#047","title":"0.4.7","text":"<p>The YAMTL jar includes the dependencies: untyped-model, and classes used for EMFatic parsing. This allows client apps to use these classes within YAMTL without having to import the dependencies explicitly.</p>"},{"location":"release-notes.html#046","title":"0.4.6","text":"<p>Metamodels can be given in EMFatic notation.</p>"},{"location":"release-notes.html#045","title":"0.4.5","text":"<p>Groovy extension for executing static operations.</p> <p>FIX call to lazy rules in ELEMENT semantics.</p>"},{"location":"release-notes.html#044","title":"0.4.4","text":"<p>Added typing information when mapping EMF models to untyped models.</p>"},{"location":"release-notes.html#043","title":"0.4.3","text":"<p>YAMTLGroovyExtensions_dynamicEMF now supports expressions of the type <code>pk.Classifier</code>.</p>"},{"location":"release-notes.html#042","title":"0.4.2","text":"<p>Added EMFComparator for testing.</p>"},{"location":"release-notes.html#041","title":"0.4.1","text":"<p>Remove YAMTLException.</p> <p>Issues with incremental AADL refinement.</p>"},{"location":"release-notes.html#039-040","title":"0.3.9-0.4.0","text":"<ul> <li>Added: getInDomains(), getOutDomains(), getInOutDomains() to know the signature of the transformations programmatically.</li> <li>GroovyExtensions are now shipped with YAMTL.</li> </ul>"},{"location":"release-notes.html#038","title":"0.3.8","text":"<p>Support for dynamic EMF in Groovy:</p> <ul> <li>Groovy extensions add syntactic sugar for getter/setter. When working with collections, use .add()/.addAll() instead of +=</li> <li>Constructor receives metamodels as parameters</li> <li>The static method YAMTLModule::loadMetamodel(filePath) returns an EPackage if the file is .ecore</li> </ul>"},{"location":"release-notes.html#037","title":"0.3.7","text":"<p>Support for Spring AOP JDK proxies:</p> <ul> <li>This allows us to execute tests without having to configure AspectJ. The proxy based mechanism slows down the runtime performance.</li> <li>We can still configure AspectJ via Spring AOP. That is, we can use AspectJ weaving through Spring AOP but we don't need to configure the AspectJ gradle tasks, which simplifies.</li> </ul> <p>JDK proxies are required to work with EMF generated code.</p> <p>Limitations: only getters that start with get are intercepted. Boolean attribute getters that start with is are not.</p>"},{"location":"release-notes.html#036","title":"0.3.6","text":"<p>Improved rule inheritance.</p> <p>When using rule inheritance, children rules need not have the same input element patterns as their parent rules. Input element calls in partial matches are extended, overriden or completed by the YAMTL matcher. This allows the rules to be specified in a much more concise way:</p> <ul> <li>Parent rules do not need to anticipate the input element patterns that will be used in the children rules.</li> <li>Children rules do not need to declare parent input element patterns if they don't use them.</li> </ul> <p>The following static checks guarantee that abstract rules are specialized by concrete rules.</p> <ul> <li>Abstract rules must be specialized by other rules.</li> <li>Concrete rules cannot be specialized by abstract rules but can have other specialised concrete rules.</li> </ul> <p>In addition, we have the following constraints:</p> <ul> <li>The order of input elements in a rule must be preserved throughout the hierarchy. PENDING</li> </ul> <p>Diamond problem is avoided as follows:</p> <ul> <li>Input element pattern: an in element cannot be inherited from different parent rules. The matches now uses depth-first search of the match.</li> <li>Output element pattern: the out element can be inherited from two separate rules and a top-down left-most evaluation strategy is used to apply the actions of the out elements along the rule hierarchy.</li> </ul>"},{"location":"release-notes.html#035","title":"0.3.5","text":"<ul> <li>Explicit <code>with</code> dependencies between <code>in</code> elements in the input pattern to guide the matching is not needed anymore. By default, YAMTL takes into account the order in which <code>in</code> elements appear in each rule. </li> <li>With inheritance:</li> <li>Parent rules can have <code>in</code> domains that need not be specified in a child rule. In this case, the domain is inherited in the child rule. In addition, a child rule may override the domain, in which case the filters of the domain in the parent classes is ignored.</li> <li>Child rules can have <code>in</code> domains that need not be specified in a parent rule. In this case, the pattern is extended and internally YAMTL lifts the domain (without filters) to the parent rules so that the match of parent rules is complete, w.r.t. the most concrete rules.</li> </ul>"},{"location":"release-notes.html#034","title":"0.3.4","text":"<p>Rules with priorities: * PROBLEM: priorities were taken into account during matching but not for executing each transformation step * SOLUTION: priorities are also taken into account for the execution phase. The logic has updated in propagation mode as well so that priorities are considering when executing transformation rules in incremental mode. More testing is desirable.</p>"},{"location":"release-notes.html#033","title":"0.3.3","text":"<ul> <li>Polyglot YAMTL via functional interfaces: Xtend, Groovy, Java, Kotlin</li> <li>UntypedModel support for Groovy dialect of YAMTL, using Groovy as host language</li> <li>UntypedModel support for Xtend, via a YAMTLModule extension</li> </ul>"},{"location":"release-notes.html#032","title":"0.3.2","text":"<ul> <li>Lazy transformation rules can be executed with a list of arguments. This feature enables the caller rule to pass context to the lazy transformation step. Arguments are available within the execution context and can be retrieved with <code>fetch</code>.</li> </ul>"},{"location":"release-notes.html#030","title":"0.3.0","text":"<ul> <li>The <code>RuntimeModel</code> has been renamed to <code>UntypedModel</code>. YAMTL can import/export untyped models from/to: CSV, XML, JSON. It can import untyped models from EMF. </li> <li>Improved invocation of static operation helpers. When the argument list of the operation is immutable, the call will be indexed.</li> <li>Improved storing models: all root objects are stored, independently of where they are created. Previously only root notedes mapped to input objects by trafo steps could be stored.</li> </ul>"},{"location":"release-notes.html#029","title":"0.2.9","text":"<ul> <li>EMF models can be loaded as runtime models using <code>YAMTLModule::loadAsRuntimeModel</code>.</li> </ul>"},{"location":"release-notes.html#028","title":"0.2.8","text":"<ul> <li>The containment hierarchy of an EMF model (including attribute values) can be serialised to JSON/CSV via the runtime model.</li> <li>Support for setting feature values of a <code>dynamicEObject</code> with <code>set</code> in a YAMTL transformation.</li> <li>Upgrade to Xtext 2.29.0 to support target compatibility with Java 17.</li> </ul>"},{"location":"release-notes.html#027","title":"0.2.7","text":"<ul> <li>Support for parsing CSV, JSON as runtime models</li> <li>Support for storing output runtime models as CSV, JSON</li> </ul>"},{"location":"release-notes.html#026","title":"0.2.6","text":"<ul> <li>YAMTL transformations without metamodel via the RuntimeModel</li> <li>Basic inference of feature types from unstructured data sources (CSV at the moment)</li> </ul>"},{"location":"release-notes.html#025","title":"0.2.5","text":"<ul> <li>Upgrade to Java17, AspectJ 1.9.9.1, Gradle 7.5.1, Xtext 2.28.28, EMF change model 2.14.0, Ecore 2.17.0</li> </ul>"},{"location":"release-notes.html#024","title":"0.2.4","text":"<ul> <li>Rules <code>toMany</code> need to declare the termination condition in the expression <code>toManyCap</code>, which returns an integer representing the number of occurrences of the match.</li> <li><code>toManyCap</code> expressions are not inherited and all concrete rules <code>toMany</code> need to have an expression <code>toManyCap</code>.</li> <li><code>matchCount</code> is an internal variable available at execution time but not at matching time (it cannot be used in filter expressions).</li> </ul>"},{"location":"release-notes.html#023","title":"0.2.3","text":"<ul> <li>Boilerplate code generation using <code>YAMTLModule::generateBoilerplateCode</code></li> <li>Adds explicit typing to rules and there is no need to fetch variables from store. In addition, the IDE code completion can be used to write the body of a filter/output action.</li> <li>Built-in helpers are generated too with the right return type. Built-in helpers are generated depending on the configuration parameters of the transformation. For example:<ul> <li><code>matchCount</code> is enabled when there are rules that are <code>toMany</code></li> <li><code>dirtyObjects</code> and <code>dirtyFeatures</code> are generated when <code>enableExplicitIncrementality</code></li> </ul> </li> </ul>"},{"location":"release-notes.html#022","title":"0.2.2","text":"<ul> <li>YAMTLModule configuration parameters:</li> <li><code>fromRoots = true</code> indicates that an input model can be transformed from root objects following containment references explicitly in transformation rules. By default, this parameter is now set to false.</li> <li><code>enableCorrectnessCheck = true</code> indicates whether the mapping semantics check is enabled or disabled. By default it is true, which is useful for developing model transformations. </li> <li>NEW FEATURE (experimental): matched rules <code>toMany</code> are used to enable several rule applications for the same input match, as defined by the filter of the rule. The consequences are that:</li> <li>An input match can be mapped to a list of output matches. Output actions must be independent of the rule filters as the rule as filters are processed during the matching phase and output actions are executed during the execution phase.</li> <li>An input match of a rule <code>toMany</code> may be related to several output matches, depending on the occurrence of the rule application. <code>fetch</code> for an input match will return the first occurrence (<code>0</code>) by default. Other occurrences can be retrieved by appending a natural number <code>occurrence</code> to the list of arguments of <code>fetch</code>. </li> <li>The rule filter needs to define a termination condition for the repetition of matches with respect to <code>fetch('matchCount')</code>. <code>fetch('matchCount')</code> returns the number of times that a rule has been matched already and it can be used in any filter condition during the matching phase.</li> <li>To use multiple inheritance with <code>toMany</code> rules, the superrule needs to be <code>toMany</code>, and it should include a termination condition in the filter. To allow <code>toMany</code> rule to inherit from injective rules, the scheduler needs to apply repeated matching once a concrete match is found. This is not done yet.</li> <li>When rules with multiple input elements are used, the termination condition must be defined in the filter of the last matched element in order to increase the match counter when a full match is found.</li> <li>FIX issue when matching with multiple inheritance: backtracking was disabled when a non-leaf match failed  </li> <li>ChangeSpecification renamed as NotificationSpecification: specification of admissible notification. <code>YAMTLContentAdapter</code> filters notifications using this specification.</li> <li>The new ChangeSpecification defines the language of admissible changes that are to be propagated. The rest of changes are ignored. The specification is of the form <code>Map&lt;EClass,Map&lt;String,Map&lt;String,Pair&lt;YAMTLChangeType,(EObject,Object)=&gt;boolean&gt;&gt;&gt;&gt;</code> indicating <code>Type |-&gt; (Description |-&gt; (featureName |-&gt; &lt;change,condition&gt;))</code>. For example:</li> </ul> <pre><code>#{\n    DocBook.section -&gt; #{ \"paras\" -&gt; #{\n        \"Swapping paragraph\" -&gt; (YAMTLChangeType.MOVE -&gt; TRIVIAL_CHECK),\n        \"Deleting paragraph\" -&gt; (YAMTLChangeType.REMOVE -&gt; TRIVIAL_CHECK) }\n    },\n    DocBook.article -&gt; #{\n        \"sections_1\" -&gt; #{\n            \"Deleting sections\" -&gt; (YAMTLChangeType.REMOVE -&gt; TRIVIAL_CHECK)\n        } \n    },\n    DocBook.sect1 -&gt; #{ \"sections_2\" -&gt; #{\n        \"Deleting sections\" -&gt; (YAMTLChangeType.REMOVE -&gt; TRIVIAL_CHECK) },\n        \"paras\" -&gt; #{\n            \"Adding an existing paragraph to Sect1\" -&gt; (YAMTLChangeType.ADD -&gt; [ EObject eObj, Object value |\n                val sect1 = eObj as Sect1\n                val para = value as Para \n                sect1.paras.exists[it.content.startsWith(para.content)] as (EObject , Object)=&gt;boolean)         \n            ]\n        } \n    }\n} \n</code></pre>"},{"location":"release-notes.html#021","title":"0.2.1","text":"<ul> <li>Renamed propagation methods</li> <li><code>propagateDelta</code> is now called <code>applyAndPropagateDelta</code> explicitly indicating that it applies the change to the input model and then propagates it to the output model</li> <li>the new <code>propagateDelta</code> only propagates changes to the output model</li> </ul>"},{"location":"release-notes.html#020","title":"0.2.0","text":"<ul> <li>Parallel pattern matching with coarse granularity (experimental feature)</li> </ul>"},{"location":"release-notes.html#015","title":"0.1.5","text":"<ul> <li>YAMTL can use change notifications to detect changes. The input model that can be subject to changes needs to be adapted with <code>YAMTLModule::adaptInputModel()</code>.</li> </ul>"},{"location":"release-notes.html#012","title":"0.1.2","text":"<ul> <li>Indexing engine (experimental feature)</li> <li>Internal optimizations</li> </ul>"},{"location":"release-notes.html#011","title":"0.1.1","text":"<ul> <li>allInstances is not a callable element</li> <li>bug fixes</li> <li>refactored ChangeDescription analysis</li> </ul>"},{"location":"release-notes.html#010","title":"0.1.0","text":"<p>Incremental evaluation of callable elements (experimental feature): * allInstances,  * staticAttribute,  * contextualOperation, * localInputFilter, * localOutputAction, * trafoStep</p> <p>Incremental evaluation at element level excludes: derivedWith, globalFilter, using, undoAction, endWith. These elements of a transformation rule need can be evaluated incrementally at the level of transformation step. Backward compatibility with TrafoStep incrementality.</p> <p>New features of the language: * HelperCall: staticAttribute, contextualOperation. The body of helpers must be purely functional. * DSL with polished syntax for rules and helpers: no more .build() * impactAnalysis and evaluateAndPropagate at element level * Lazy initialization of static attribute helpers * Standalone helpers</p>"},{"location":"release-notes.html#0011-snapshot","title":"0.0.11-SNAPSHOT","text":"<ul> <li>AspectJ configuration is now delegated to client code: aop.xml and aspects.</li> <li>Some initialization (deltaMatchPool) is partially reused between propagation of deltas.</li> <li>loadDelta() returns the delta where it is stored.</li> </ul>"},{"location":"release-notes.html#0010-snapshot","title":"0.0.10-SNAPSHOT","text":"<p>Binaries compiled with Java 11.</p>"},{"location":"release-notes.html#009-snapshot","title":"0.0.9-SNAPSHOT","text":"<ul> <li>FIX: During impact analysis of deltas, objects are added to the typeExtend when processing dirty objects only  and not when processing dirty features.</li> <li>OPTIMIZATION: Actions of out elements initialized to null by default.</li> <li>OPTIMIZATION: When undoing trafo steps, out elements are traversed when they have undo actions only.</li> <li>NEW FEATURE: When matching, to identify which trafoSteps are affected by featureCalls, YAMTL understands the plural of feature names, in case the name of the getter is different from the name of the feature.</li> <li>An example of such a metamodel is OSATE AADL, where one can find many-bounded features with name <code>componentInstance</code> whereas the corresponding getter is <code>getComponentInstances()</code>. Feature requested for AADL2AADL trafo provided by Hana Mkaouar, T\u00e9l\u00e9com Paris.</li> </ul>"},{"location":"release-notes.html#008-snapshot","title":"0.0.8-SNAPSHOT","text":"<ul> <li>FIX: Derived features were unset when re-executing transformation steps in propagation mode. This is no longer the case.</li> <li>Found thanks to update case in AADL2AADL trafo provided by Hana Mkaouar, T\u00e9l\u00e9com Paris.</li> </ul>"},{"location":"release-notes.html#007-snapshot","title":"0.0.7-SNAPSHOT","text":"<ul> <li>FIX: Fetching elements with lazy rules that had more than one input element failed. An assertion now checks whether the arguments correspond to inElement patterns.</li> </ul>"},{"location":"release-notes.html#006-snapshot","title":"0.0.6-SNAPSHOT","text":"<ul> <li>Compatibility with Java 8</li> <li>Static type checking of the transformation declaration now happens when the transformation module is instantiated.</li> <li>The method <code>YAMTLModule.reset()</code> also deletes the <code>typeExtent</code> when locations initialized using the aspect <code>InitLocations</code>. When locations are initialized from the model registry in <code>YAMTLModule.execute()</code>, reset does not clear the <code>typeExtent</code>. </li> </ul>"},{"location":"release-notes.html#005-snapshot","title":"0.0.5-SNAPSHOT","text":"<ul> <li>FIX: static helpers (in the helper store of a transformation) can now be used in rule filters.</li> <li>Support for delta analysis on target models</li> <li>More fine grained analysis of deltas</li> <li>Support for inconsistency specifications, with visual reporting using PlantUML</li> <li>FIX solve diamond bugs: </li> <li>bottom rule can only be matched when all of its superrules can match</li> <li>bottom rule only executes actions once: when analysing the transformation statically, the bottom rule could get duplicate out elements by importing the same top outElements from different parents</li> <li>FIX matching bug when matching with class inheritance: an object can be a match either for a type in an inElement or for ANY of its supertypes</li> <li>FIX: dependencies only need to be tracked in incremental/propagation modes: normal mode was doing some unnecessary work in insertTupleMatch for feature calls/helpers</li> <li>Added flag <code>YAMTLModule::warnings-on</code> (by default set to <code>true</code>), which can be used to error warning messages in the output stream</li> <li>Added flag <code>YAMTLModule::initialSizeFactor</code> to indicate the initial size of the matchPool (10000 by default)</li> </ul>"},{"location":"release-notes.html#004-snapshot","title":"0.0.4-SNAPSHOT","text":"<ul> <li>Initialization of locations can be disabled during loading. This change breaks previous versions that were relying on this feature. To solve this problems, set the following configuration option in the runner: <code>YAMTLModule::initLocationsWhenLoading = true</code> </li> </ul>"},{"location":"release-notes.html#003-snapshot","title":"0.0.3-SNAPSHOT","text":"<ul> <li>Upgrade to Java 11, Gradle 5, Xtend 2.17.1</li> </ul>"},{"location":"release-notes.html#002-snapshot","title":"0.0.2-SNAPSHOT","text":"<ul> <li>Support for incremental declarative m2m transformations (<code>mapping</code> semantics).</li> </ul>"},{"location":"release-notes.html#001-snapshot","title":"0.0.1-SNAPSHOT","text":"<ul> <li>Support for batch declarative m2m transformations (<code>mapping</code> semantics):</li> <li>n-m m2m rules;</li> <li>local-search pattern matching with facilities for encoding search plans;</li> <li>filters and actions written using Xtend expressions;</li> <li>operations <code>fetch</code> and <code>allInstances</code>;</li> <li>matched/lazy/unique lazy rules.</li> <li>Rules with multiple inheritance.</li> <li>Experimental support for <code>rewriting</code> semantics.</li> </ul> <p>\u00a9 Artur Boronat, 2018</p>"},{"location":"yamtl-ide.html","title":"Choosing an IDE","text":"<p>To use YAMTL appropriately, an IDE must be properly configured. Let\"s check out the required configurations for some of the most popular IDEs: Eclipse, IntelliJ, and VSCode.</p>"},{"location":"yamtl-ide.html#eclipse","title":"Eclipse","text":"<p>Open Eclipse IDE and head over to <code>Help \u2192 Eclipse Marketplace</code>. Enter \"Groovy\" and install <code>Groovy Development Tools 5.0.0.RELEASE</code> to be able to run Groovy scripts.</p> <p>Before you run any tasks, make sure your project is using JDK 17 or higher.</p> How to change the Java version in Eclipse <p>To change your JRE, head over to <code>Eclipse \u2192 Preferences \u2192 Java \u2192 Installed JREs \u2192 Choose Java SE 17 or higher</code></p> <p>Now you should be ready to use YAMTL in your modeling projects.</p>"},{"location":"yamtl-ide.html#intellij","title":"IntelliJ","text":"<p>Head over to <code>IntelliJ IDEA \u2192 Preferences \u2192 Plugins</code> and search for <code>Eclipse Groovy Compiler Plugin</code> and install it.</p> <p>Similarly, search for \"gradle\" and install the <code>Gradle</code> plugin from JetBrains. Restart your IDE to apply the changes.</p> <p>Ensure the project is using JDK 17 or higher.</p> How to change the Java version in IntelliJ <p>To change your JDK, head over to <code>IntelliJ IDEA \u2192 Preferences \u2192 Build, Execution, Deployment \u2192 Build Tools \u2192 Gradle</code>. Then, select a <code>Gradle JVM</code> that is JDK 17 or higher.</p> <p>All necessary configurations are now completed!</p>"},{"location":"yamtl-ide.html#vscode","title":"VSCode","text":"<p>First, a groovy support package must be installed. <code>code-groovy</code> extension enables Groovy support for VSCode. In VScode, click on <code>Extensions</code> and search for \"code-groovy\". Install the extension from Marlon Franca.</p> <p>Also, install the <code>Gradle for Java</code> extension published by Microsoft to run the Gradle scripts in a neat interface.</p> <p>Make sure the workspace is using JDK 17 or higher.</p> How to change the Java version in VSCode <p>To change your JRE, head over to <code>Code \u2192 Preferences \u2192 Settings</code> and search for \"JDK\". Check the Gradle <code>Java: Home</code> setting to see if the path points to a location of JDK 17 or higher (update the JDK version if it is any lower).</p> <p></p> <p>The configurations are completed! Get started with YAMTL by installing some dependencies.</p>"},{"location":"yamtl-reference.html","title":"YAMTL Language Reference","text":"<p>In YAMTL, <code>YAMTLModule</code> is a foundational class that provides the core functionality and infrastructure for defining and executing model transformations. It serves as the base class for any transformation module, offering access to the YAMTL DSL and methods necessary for configuring and running transformations.</p> <p>The key roles of <code>YAMTLModule</code> are:</p> <ol> <li> <p>Configuration: <code>YAMTLModule</code> is used to set up the transformation environment, including input and output models, namespaces, and execution modes.</p> </li> <li> <p>Transformation Definition: It allows users to define transformation rules, helpers, and various other elements necessary for transforming models.</p> </li> <li> <p>Execution Control: It provides methods to execute the transformation, propagate changes, and manage incremental transformations.</p> </li> <li> <p>Utility Methods: It includes utility commands like <code>fetch()</code> and <code>allInstances()</code> to facilitate querying and manipulating model elements during transformation.</p> </li> </ol> <p>The following section describes how to use it.</p>"},{"location":"yamtl-reference.html#basic-syntax","title":"Basic Syntax","text":"<p>A YAMTL model transformation is defined as a class that specializes the <code>YAMTLModule</code> class, which provides access to the YAMTL DSL and to methods to configure and execute model transformations:</p> GroovyXtendJavaKotlin <pre><code>class &lt;name&gt; extends YAMTLModule {\n    public &lt;name&gt; (EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n        header().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\n        ruleStore([ /* rules here */ ])\n        helperStore([  /* managed helpers here */ ])\n    }\n}\n</code></pre> <pre><code>class &lt;name&gt; extends YAMTLModule {\n    new(EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\n        header().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\n        ruleStore(#[ /* rules here */ ])\n        helperStore(#[ /* managed helpers here */ ])\n    }\n}\n</code></pre> <pre><code>public class &lt;name&gt; extends YAMTLModule {\n    public &lt;name&gt;(EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\n        header().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;);\n        ruleStore(List.of( /* rules here */ ));\n        helperStore(List.of( /* managed helpers here */ ));\n    }\n}\n</code></pre> <pre><code>class &lt;name&gt;(&lt;pk1&gt;: EPackage, &lt;pk2&gt;: EPackage) : YAMTLModule() {\n    init {\n        header().`in`(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\n        ruleStore(listOf( /* rules here */ ))\n        helperStore(listOf( /* managed helpers here */ ))\n    }\n}\n</code></pre> <p>In the code above there are four important sections:</p> <ul> <li>Constructor signature: It should include the different metamodels (<code>EPackage</code> instances) used in the transformation. </li> <li>Header: This section declares the signature of the model transformation using a unique name for each domain and its corresponding metamodel, which can be shared across domains.  </li> <li>Rule Store: This section declares a list of transformation rules.</li> <li>Helper Store (Optional): Accepts a list of managed helpers. Managed helpers are attributes or methods that are optimized in YAMTL using an internal cache for their results. Unmanaged helpers are declared as standard methods of the module class. This section is optional if no managed helpers are needed.</li> </ul> <p>Static Typing for Accessors/Mutators</p> <p>If you generate code from Ecore models within the Eclipse Modeling Framework, there is no need to declare <code>EPackage</code> parameters for the headers. These are accessible from the <code>eINSTANCE</code> associated with each <code>&lt;X&gt;Package</code> class, where <code>&lt;X&gt;</code> is the name of your <code>EPackage</code> in the Ecore model. Once the models are stable, generated code will provide several advantages: 1. Static typing and code completion in IDEs. 2. Optimized performance at runtime: accessors/mutators will not need to use generic EMF reflection. 3. Groovy is the only language configured to work with dynamic EMF models (i.e., models whose metamodel is given as an Ecore model but not implemented in Java). Other languages (Java, Kotlin, Xtend, etc.) will benefit from generated code to avoid using lengthy expressions with the EMF API.    </p> <p>However, if you are still experimenting with your Ecore models, we recommend working with dynamic EMF models and the YAMTL Groovy DSL for faster prototyping.</p> <p>The basic format of a YAMTL rule definition is as follows:</p> <pre><code>rule(\"&lt;name&gt;\")\n    .in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)\n        [.derivedWith(&lt;QUERY&gt;)]?\n        [.filter(&lt;FILTER&gt;)]?\n    .out(\"&lt;out_object_name&gt;\", &lt;out_object_type&gt;, &lt;ACTION&gt;)\n</code></pre> <p>Legend</p> <p><code>&lt;&gt;</code> indicates user-definable expressions. Note that these are placeholders and not part of the actual YAMTL syntax. Lowercase snake case (e.g., <code>in_object_name</code>) usually denotes variable names and types, including lists of variable names. Uppercase snake case (e.g., <code>&lt;FILTER&gt;</code> or <code>&lt;ACTION&gt;</code>) represents lambda expressions, and they are written using the syntax of the host language. <code>[]?</code> means optional.</p> <p>A rule is declared using <code>rule(\"&lt;name&gt;\")</code> with a rule name. The static operation <code>rule</code> can be used with <code>import static yamtl.dsl.Rule.*</code>. Each rule consists of one or more input element(s), defined using <code>in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)</code> operation that requires a source element name and type; an optional <code>.derivedWith(&lt;QUERY&gt;)</code> clause where <code>&lt;QUERY&gt;</code> is a lambda expression of type <code>Supplier&lt;EObject&gt;</code> that produces the object that will be matched to the input element; an optional filter condition expressed with <code>filter(&lt;FILTER&gt;)</code> where <code>&lt;FILTER&gt;</code> is a lambda expression of type <code>Supplier&lt;Boolean&gt;</code>; and one or more output element(s), declared with <code>out(\"out_object_name\", &lt;out_object_type&gt;, &lt;ACTION&gt;)</code> requiring a target element name and type, along with a side-effecting lambda expression <code>&lt;ACTION&gt;</code> of type <code>Runnable</code> containing action statements that initialize or update the output object attributes and references. </p>"},{"location":"yamtl-reference.html#yamtl-semantics","title":"YAMTL Semantics","text":"<p>Model transformations can be used to define model queries by using pattern matching, out-place model transformation by mapping an input model into a new output model, or in-place model transformations by rewriting a given model.</p>"},{"location":"yamtl-reference.html#pattern-matching-semantics","title":"Pattern Matching Semantics","text":"<p>Pattern matching is the process by which YAMTL tries to find object graphs in the input model where the input pattern of a rule can be matched. </p> <p>There are two main types of input elements: matched elements, which are mapped by YAMTL to objects in the input model, and derived elements, which are defined with a <code>.derivedWith(&lt;QUERY&gt;)</code> clause and need to be derived from input elements that have been matched in preceding input elements. </p> <p>To find a match for a rule, YAMTL first maps each matched input element of the rule to objects in the input model in the order in which they appear. For derived elements, YAMTL tries to complete the total match by processing query expressions in the order that they were declared. If a query cannot be resolved to an object, that rule's match is invalid. </p> <p>A match for a matched rule must be unique. That is, no other rule should be applicable to the same match. Uniqueness of matches is checked at runtime using the flag <code>YAMTLModule::setEnableCorrectnessCheck(Boolean)</code>, which is <code>true</code> by default. Non-unique matches are allowed when using lazy rules, which are called on demand, and when using ToMany rules, which create a fixed number of rule application for the same match.</p> <p>A match is complete when all input elements are mapped to objects, either implicitly via matched input elements or explicitly via derived input elements. A match is defined as a map where the key is the input variable name and the value is the corresponding matched <code>EObject</code>.</p> <p>Model-sensitive pattern matching</p> <p>The input elements are ordered by the size of their type extent (smaller-sized types are matched before bigger ones) when enabling the flag <code>YAMTLModule::setEnabledMatchingInputElementOrderBySize(true)</code>. This can lead to significant run-time improvements when the distribution of objects across types is imbalanced.</p> <p>This optimization can, however, cause problems when the order of the input elements alters the order in which input element declaration is expected in filter expressions. For example, assuming that <code>Type1</code> declares a boolean method <code>isEnabled()</code> and that <code>Type2</code> has fewer objects than <code>Type1</code>, the order of input elements in the following input pattern</p> <pre><code>.in(\"a\", Type1)\n.in(\"b\", Type2).filter{ a.isEnabled() }\n</code></pre> <p>will be changed by the flag <code>setEnabledMatchingInputElementOrderBySize</code>. This will cause a problem because the input element <code>b</code> will be evaluated first and its filter condition needs \"a\" to be matched first. In such cases, the flag <code>YAMTLModule::setEnabledMatchingInputElementOrderBySize</code> must be kept disabled.</p> <p>A match for a rule is valid when it is unique, complete and all of the filters of the input pattern are satisfied. Filters come in two flavours:</p> <ul> <li>Local filters: defined for an input element <code>.in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;).filter(&lt;FILTER&gt;)</code>. The lambda expression <code>&lt;FILTER&gt;</code> can use any object variable declared in a preceding input element.</li> <li>Global filters: defined for the last input element of the input pattern. All input object variables can be used for defining the filter expression. A single global filter can be defined for a rule using the clause <code>.globalFilter(&lt;FILTER&gt;)</code> at the end of the input pattern. </li> </ul> <p>Design principles for efficient pattern matching</p> <ol> <li> <p>Matched input elements should only be defined for matching objects that are not related to each other through references. If they are then they should be defined as derived elements instead.</p> </li> <li> <p>Local element filter conditions should be opted for instead of global rule filter conditions to help the matching algorithm remove invalid matches as soon as possible (reduces execution time).</p> </li> <li> <p>Once it is known that only unique matches are found within a model for a given set of rules, the model transformation containing them can be executed more efficiently by disabling the uniqueness correctness check with <code>YAMTLModule::setEnableCorrectnessCheck(false)</code>.</p> </li> </ol> <p>YAMTL's pattern matcher can be used to implement model queries. A model query is a rule that only has an input pattern and that may have a final action block <code>endWith(&lt;ACTION&gt;)</code>:</p> <pre><code>rule(\"&lt;name&gt;\")\n    .in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)[.derivedWith(&lt;QUERY&gt;)]?[.filter(&lt;FILTER&gt;)]?\n    .query()\n    [.endWith(&lt;ACTION&gt;)]?\n</code></pre> <p>The <code>&lt;ACTION&gt;</code> in <code>endWith(&lt;ACTION&gt;)</code> is a lambda expression of type <code>Runnable</code> that may use the input element variables to perform some action on the input objects that have been matched, e.g., reporting error messages or computing metrics.</p> <p>To configure and execute a YAMTL module for implementing rule-based queries, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = BaseQuery.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef query = new BaseQuery(resource.contents[0])\nYAMTLGroovyExtensions.init(query)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nquery.execute()\n</code></pre> <pre><code>val resource = BaseQuery.preloadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval query = new BaseQuery(resource.contents[0] as EPackage)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nquery.execute()\n</code></pre> <pre><code>Resource resource = (Resource) BaseQuery.preloadMetamodel(\"&lt;path_to_metamodel&gt;\");\nBaseQuery query = new BaseQuery((EPackage) resource.getContents().get(0));\nquery.setSelectedExecutionPhases(ExecutionPhase.MATCH_ONLY);\nquery.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nquery.execute();\n</code></pre> <pre><code>val resource = BaseQuery.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval query = BaseQuery(resource.contents[0])\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nquery.execute()\n</code></pre> <p>When using dynamic EMF for accessing metamodel metadata (i.e., EMF code has not been generated for the metamodel), use the static method <code>YAMTLModule::loadMetamodel(\"&lt;path_to_metamodel&gt;\")</code>, which works with both Ecore files (<code>.ecore</code>) and with EMFatic files (<code>.emf</code>) to load the metamodel. Then instantiate the YAMTL module containing the model query, configure it to execute only the matching phase, load the input models and, finally, execute the query using the method <code>YAMTLModule::execute()</code>. </p> <p>The <code>&lt;path_to_metamodel&gt;</code> can also be a URL (<code>http:</code> or <code>https:</code>) to the model in an accessible remote repository.</p> <p>The results of the queries can be handled in blocks <code>endWith(&lt;ACTION)</code> of query rules, for example printing them in the output console or accumulating them in local variables.</p>"},{"location":"yamtl-reference.html#out-place-transformation-semantics","title":"Out-place Transformation Semantics","text":"<p>YAMTL modules are typically used to specify model-to-model transformations, where the objects of an input model are mapped to objects of an output model that is created from scratch. This is commonly referred to as out-place transformation because the input model is read-only and not modified.</p> <p>This semantics is characterized by the following properties:</p> <ul> <li>Immutability of Source Models: The input model remains immutable during the transformation process. Consequently, a new output model is generated to encapsulate the transformation result, thereby preserving the integrity of the original input model. This immutability eliminates the risk of unintended side effects that could potentially alter the source model in undesirable ways.</li> <li>Separation of Concerns: Out-of-place transformations naturally enable a clear separation of concerns between the input and output models. This is beneficial for modularisation and reusability of transformation rules, as each rule can be designed to perform a specific, self-contained task without affecting the input model.</li> <li>Traceability and Versioning: The creation of a separate output model in out-of-place transformations provides better support for traceability and versioning. Each transformation produces a new model that can be stored, compared, and traced back to its originating source model. This facilitates debugging, testing, and long-term maintenance. This feature also enables the incremental execution of model transformations based on change propagation from the input model to the output model.</li> </ul> <p>Side effects in a model transformation are specified in the <code>out</code> elements of rules. For each transformation rule that has been matched, the rule is applied by creating an object in the output model for each <code>out</code> element and the object is initialized using the corresponding <code>&lt;ACTION&gt;</code> expression. Within a rule, an <code>ACTION</code> expression can refer to:</p> <ul> <li>the input object variables (either matched or derived) of that rule, </li> <li><code>using</code> variables of that rule, and </li> <li>all output object variables of that rule.</li> </ul> <p>To configure and execute a YAMTL module for implementing an out-place transformation, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef xform = new XForm(resource.contents[0])\nYAMTLGroovyExtensions.init(xform)\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nxform.execute()\nxform.saveOutputModels([\"&lt;out_domain_name\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>val resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval xform = new XForm(resource.contents[0] as EPackage)\nxform.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nxform.execute()\nxform.saveOutputModels(#[ \"&lt;out_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\n</code></pre> <pre><code>Resource resource = (Resource) YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\");\nXForm xform = new XForm((EPackage)resource.getContents().get(0));\nxform.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nxform.execute();\nxform.saveOutputModels(Collections.singletonMap(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>val resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval xform = XForm(resource.contents[0])\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nxform.execute()\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>When an expression needs to reference output objects that are initialized by other rules, the operation <code>YAMTLModule::fetch()</code> needs to be used. The primary purpose of the <code>fetch</code> operation is to retrieve output objects corresponding to a given input object through the application of a transformation rule. The simplest version is suitable for matched rules that have a single object pattern in both the input and output patterns: <code>fetch(input_matched_object)</code> will return the output object created by the rule that matched <code>input_matched_object</code>.</p> <p>Using Actions Effectively</p> <p>In a rule with an output element <code>.out(&lt;out_object_name&gt;, &lt;out_object_type&gt;, &lt;ACTION&gt;)</code>, the expression <code>&lt;ACTION&gt;</code> should only be used to initialize the output object of type <code>&lt;out_object_type&gt;</code> that is created by this output element.</p> <p>Creation of Objects</p> <p>YAMTL augments mainstream JVM programming languages with declarative model transformation capabilities, yet imperative features of the host languages can still be used. Declarative object creation is normally handled in <code>out</code> elements in the output pattern of a rule, when an output element is defined with a new name it creates a new instance of the initialized object. </p> <p>Using imperative features, ad-hoc objects that are manually created using an object factory and assigned to an output element in the <code>ACTION</code> expression, are not traced by YAMTL. This means such non-traced objects cannot be fetched from another rule using the operation <code>fetch()</code>.</p>"},{"location":"yamtl-reference.html#in-place-semantics","title":"In-place Semantics","text":"<p>This semantics is experimental.</p> <p>An in-place transformation in YAMTL is a model transformation where the model is modified directly to produce the desired output model, without creating a new or separate model as the output. In other words, the transformation process occurs within the same model instance, and the original model is incrementally updated to match the structure and content specified by the transformation rules.</p> <p>This approach has several implications and characteristics:</p> <ul> <li>Mutability of Source Models: In in-place transformations, the input model is mutable, meaning that its elements can be modified during the transformation process. This is in contrast to out-of-place transformations, where a new model is created as the output, leaving the input model unchanged.</li> <li>Efficiency: In-place transformations can be more efficient in terms of memory usage and execution time compared to out-of-place transformations, especially when dealing with large models. This efficiency is due to the avoidance of duplicating the entire input model structure in the output model. </li> <li>Potential Side Effects: Since the input model is modified directly, it is essential to carefully manage and control potential side effects. Changes made during the transformation might affect the application of transformation rules or introduce inconsistencies if not handled correctly.</li> </ul> <p>When declaring an in-place transformation, the header of the module containing the in-place transformation rules must identify the parameter that refers to the model to be modified in-place using the keyword <code>inOut</code>: <code>header().inOut(&lt;inOut_domain_name&gt;,&lt;pk&gt;)</code>.</p> <p>YAMTL in-place transformations can be both additive and subtractive:</p> <ul> <li>To create new objects, use <code>out</code> elements in rule output patterns that do not correspond to an <code>in</code> domain, or any of its parent rules.</li> <li>To update existing objects, use <code>out</code> elements in rule output patterns that do correspond to an <code>in</code> domain of the same rule, or any of its parent rules.</li> <li>To delete objects that exist in the model, use <code>.drop()</code> on the corresponding <code>out</code> element that refers to an <code>in</code> element. The <code>in</code> element must be matched by the rule in order for it to be deleted. When using <code>.drop()</code> the following flag must be disabled for the module <code>xform.enableUpdateExtent(false)</code>, where <code>xform</code> refers to the YAMTLModule instance that declares the model transformation rules. <code>drop()</code> has delete cascade semantics that indicates both the object and its contents following containment references are removed. When an object is deleted from the model, all the objects contained through containment references in it will also be removed.</li> <li>YAMTL also offers a less dramatic option to avoid deleting objects from the model by freezing parts of the model. An object in the model is said to be frozen when YAMTL's pattern matcher is oblivious to it.  Objects can be frozen/unfrozen using the operations <code>.freeze()</code>/<code>.unfreeze()</code> on <code>inOut</code> elements, i.e. to those <code>out</code> elements whose name and type coincides with an <code>in</code> element. When using  <code>.freeze()</code>/<code>.unfreeze()</code> the following flag must be disabled for the module <code>xform.enableUpdateExtent(false)</code>, where <code>xform</code> refers to the YAMTLModule instance that declares the model transformation rules. </li> </ul> <p>Since rules are applied over a model in-place, the side-effect of a rule application may enable additional rules and the pattern matching process needs to be performed iteratively. YAMTL provides two strategies to evaluate rules:</p> <ul> <li>Single-Match Mode: As soon as the pattern matcher finds a match, the associated rule is executed. This mode is enabled with the flag <code>xform.setWithStagedExecution(false)</code>, where <code>xform</code> is the <code>YAMTLModule</code> instance containing the declaration of transformation rules. In case of non-terminating transformations, the number of transformation steps can be limited by setting a cap using <code>YAMTLModule::setTransitionUpperBound(Long)</code>, which by default is set to <code>Long.MAX_VALUE</code>.</li> <li>Staged Mode: Rules are evaluated in stages, where each stage involves identifying all applicable matches prior to rule execution. This evaluation mode is similar to the evaluation strategy used in out-place transformations. The difference is that the transformation may consist of different stages. This mode is enabled with the flag <code>xform.setWithStagedExecution(true)</code>, where <code>xform</code> is the <code>YAMTLModule</code> instance containing the declaration of transformation rules. The number of stages that are perfomed can also be capped using <code>YAMTLModule::setStageUpperBound(Long)</code>, which by default is set to <code>1</code>.</li> </ul> <p>To configure and execute a YAMTL module for implementing an in-place transformation, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef xform = new XForm(resource.contents[0])\nYAMTLGroovyExtensions.init(xform)\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\n\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nxform.execute()\nxform.saveOutputModels([\"&lt;out_domain_name\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>val resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval xform = new XForm(resource.contents[0] as EPackage)\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\n\nxform.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nxform.execute()\nxform.saveOutputModels(#[ \"&lt;out_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\n</code></pre> <pre><code>Resource resource = (Resource) YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\");\nXForm xform = new XForm((EPackage)resource.getContents().get(0));\nxform.setInplace(true); // enables the in-place transformation semantics\nxform.setWithStagedExecution(false); // YAMTL to use one match at a time\nxform.enableUpdateExtent(false); // to be used with drop() and freeze()/unfreeze()\n\nxform.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nxform.execute();\nxform.saveOutputModels(Collections.singletonMap(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>val resource = YAMTLModule.preloadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval xform = XForm(resource.contents[0])\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\n\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nxform.execute()\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>In-place semantics and fetch()</p> <p>The mapping from input match to output match is traced as a transformation step in the out-place semantics only. In the in-place semantics, transformation steps are not traced and the <code>fetch()</code> operation cannot be used to resolve references to output objects from input objects (or the matches that contain them). The reason is that the transformation executes modifications on the input model, and references to objects in that model are reachable and need not be resolved using <code>fetch()</code>.</p>"},{"location":"yamtl-reference.html#yamtl-header","title":"YAMTL Header","text":"<p>A YAMTL header is a configuration section within a YAMTL transformation module that specifies the input and output domains for the transformation. It serves as the signature of the transformation, defining which metamodels (EPackage instances) are used for the source (input) and target (output) models.</p> <p>The purpose of the YAMTL Header is as follows:</p> <ol> <li>Define Input and Output Models: The header specifies the metamodels for the input and output domains, establishing the types of models that the transformation will work with.</li> <li>Set Transformation Context: It provides context for the transformation rules, ensuring that the rules can refer to the correct metamodels and their elements.</li> <li>Initialization: It initializes the transformation module with the necessary metadata about the models, enabling the YAMTL engine to understand the structure and elements of the input and output models.</li> </ol> <p>The header is usually defined within the constructor of a class that extends <code>YAMTLModule</code>. It uses the <code>header()</code> method to declare the input and output domains, followed by the specification of rules and helpers.</p> <p>Each component of a header is called domain. In YAMTL, the following component types are supported:</p> <ol> <li>Input Domain (<code>in</code>): Specifies the name and EPackage of the input model domain for out-place transformations.</li> <li> <p>Example: <code>.in(\"sourceDomain\", pk1)</code></p> </li> <li> <p>Input/Output Domain (<code>inOut</code>): Specifies the name and EPackage of an input/output model domain for in-place transformations.</p> </li> <li> <p>Example: <code>.out(\"targetDomain\", pk2)</code></p> </li> <li> <p>Output Domain (<code>out</code>): Specifies the name and EPackage of the output model domain for out-place transformations.</p> </li> <li>Example: <code>.out(\"targetDomain\", pk2)</code></li> </ol> <p>The header is used as follows:</p> <ul> <li> <p>Rule Definitions: The rules defined in the transformation module use the domains specified in the header to match and transform elements. For instance, a rule might match elements from the input domain and create corresponding elements in the output domain.</p> </li> <li> <p>Model Loading: When executing the transformation, the models corresponding to the input and output domains are loaded based on the header configuration.</p> </li> <li> <p>Helper Functions: Helpers defined in the module can use the domains to perform operations on the models, like <code>allInstances()</code>, ensuring that they work within the correct context.</p> </li> </ul> <p>The YAMTL header is essential for setting up the transformation context, ensuring that the transformation rules and helpers operate within the correct metamodel framework. The following constraints should be considered:</p> <ol> <li>Using <code>inOut</code> domains enables in-place semantics, and <code>in</code>/<code>out</code> domains must be avoided in such cases. Conversely, <code>in</code>/<code>out</code> domains enable out-place semantics and pattern-matching semantics and must not be used with <code>inOut</code> domains.</li> <li>Using several <code>in</code>/<code>out</code> domains for out-place transformations or model patterns, as well as using several <code>inOut</code> domains for in-place transformations, leads to multi-model transformation. A multi-model transformation enables the use of the pattern matcher across domains, for example, to define constraints over different metamodels, and facilitates the production of multiple output models. In a multi-model transformation, whenever we refer to a specific type (in object element patterns for <code>in</code>/<code>out</code> patterns of rules or in <code>allInstances()</code>), we must specify which domain the class belongs to. This is necessary to avoid confusion when the same metamodel is used for multiple domains.</li> </ol>"},{"location":"yamtl-reference.html#yamtl-rules","title":"YAMTL Rules","text":"<p>YAMTL is as expressive as ATL so it also has a lot of optional operations. These options provide a more thorough (full) syntax for the language.</p> <pre><code>rule(\"&lt;name&gt;\")\n    [.inheritsFrom(&lt;ruleNameList&gt;)]? \n    [.isAbstract()]? \n    [.isLazy() | .isUniqueLazy()]? \n    [.isTransient()]?\n    {\n        .in(\"&lt;in_object_name&gt;\", (&lt;domain_name&gt;,)? &lt;in_object_type&gt;) \n        [(.filter(&lt;FILTER&gt;) | .derivedWith(&lt;QUERY&gt;))]?\n    }+\n    [.using(\"&lt;var_name&gt;\", &lt;QUERY&gt;)]*\n    [.globalFilter(&lt;FILTER&gt;)]?\n    {\n        .out(\"&lt;out_object_name&gt;\", (&lt;domain_name&gt;,)? &lt;out_object_type&gt;, &lt;ACTION&gt;)\n        [.overriding()]?\n        [.drop()|.freeze()|.unfreeze()]?\n    }+\n    [.endWith(&lt;ACTION&gt;)]?\n    [.priority(P)]?\n</code></pre> <p>Legend</p> <p><code>&lt;&gt;</code> indicates user-definable expressions, <code>[]?</code> means optional, <code>[]*</code> means operation can occur 0 or more times, <code>{}+</code> means operation can occur 1 or more times. These symbols are not part of the actual YAMTL syntax.</p> <p>YAMTL has two types of input elements: matched and derived. Matched elements are initialized using YAMTL's matching algorithm, whereas derived elements are initialized using a contextual query and are dependent on at least one matched element. Intuitively, each rule has at least one matched input element as you would expect.</p> <p>Every rule has several options for additional customization. They will be discussed from top to bottom of the full syntax provided above:</p> <ul> <li>The <code>inheritsFrom(&lt;ruleNameList&gt;)</code> operation is declared when the current rule inherits from parent rule(s) where <code>ruleNameList</code> is a comma-separated list of strings and the order of inheritance is specified sequentially. An optional <code>abstract</code> tag is used for abstract rules which cannot be matched automatically or applied. </li> <li>Lazy rules can be declared with <code>isLazy()</code> or <code>isUniqueLazy()</code>. These rules are only applicable when the matched input elements are explicitly provided using an expression involving the operation <code>fetch</code>. </li> <li>A rule defined as <code>isTransient()</code> does not persist the target (output) elements when the target model flushes to physical storage.</li> </ul> <p>The input pattern in a rule determines where the rule should be applied and it consists of at least one input element, which can be configured with the following options: * In multi-model transformations, the <code>in</code> element must specify the domainName that it refers to. * A <code>filter(&lt;FILTER&gt;)</code> clause enables the user to add a local filter condition that needs to be satisfied by the matched object of the corresponding input element.  * A <code>derivedWith(&lt;QUERY&gt;)</code> clause is used to declare an input element as derived where <code>QUERY</code> is a lambda expression of the \"EObject\" type used to calculate the value of the match. </p> <p>Rules can be equipped with local variables that can be initialized with using the matched variables. Such local variables are helpful for holding primitive values obtained from the matched objects. These are declared with the block <code>.using(\"&lt;var_name&gt;\", &lt;QUERY&gt;)</code>, where <code>&lt;var_name&gt;</code> is the name of the variable, and <code>&lt;QUERY&gt;</code> is an expression of type <code>Supplier&lt;Object&gt;</code>, which should return the variable value. Local variables can then be used in global filters and actions, both in <code>out</code> elements and in the block <code>endWith</code>.</p> <p>A global filter condition for a rule can be added after the input element block using <code>globalFilter(&lt;FILTER&gt;)</code> clause which allows the user to add filter(s) applicable to the global scope of the rule.</p> <p>The output pattern of a rule defines the side effects of the rule and consists of at least one output element, which can be configured with the following options: * In multi-model transformations, the <code>out</code> element must specify the domainName that it refers to. * An <code>overriding()</code> qualifier is used to override inherited action expression(s) in the output element of a descendant rule, as discussed in rule inheritance. * Elements that are used both as input and output can be managed using the options <code>.drop()</code> or <code>.freeze()/.unfreeze()</code>, as explained in the Subsection In-place Semantics.</p> <p>Rules can also have the option <code>endWith(&lt;ACTION&gt;)</code> to define an optional <code>&lt;ACTION&gt;</code>, of type <code>Runnable</code>, that can refer to any of the rule's elements and any local variables. Note that the <code>endWith()</code> method is purely for convenience: it enables performing actions at the end of the rule execution for each particular match. </p> <p>To change the priority of a rule, you can use the <code>priority(P)</code> operation where P is a \"long\" value. Rules with lower priority are applied first by the YAMTL matching algorithm. Additionally, YAMTL provides attribute helpers for computing values during the initialization of the model transformation. </p> <p>The helpers are defined in  the block <code>helperStore()</code> of the the transformation's constructor. The helper syntax <code>Helper(\"&lt;helperName&gt;\")</code> is used to define an attribute helper with the name in single quotes and is followed by a query lambda expression enclosed in square brackets. </p>"},{"location":"yamtl-reference.html#lazy-rules","title":"Lazy Rules","text":"<p>Lazy rules, similar to matched rules, transform input objects into output objects. However, unlike matched rules that apply automatically, lazy rules must be explicitly invoked. This can be achieved using the fetch() operation. Since they only execute when called, they produce outputs based on specific inputs without unnecessary runs. This ensures that transformations only occur when required, enhancing both modularisation and efficiency.</p> <p>There are two types of lazy rules:</p> <ul> <li>Standard Lazy Rules (<code>isLazy()</code>): These are the basic form of lazy rules. Once called, they take specified input elements from the input model and produce corresponding output elements in the output model. However, if invoked multiple times with the same inputs, they may produce redundant output elements. A typical use case that illustrates the use of rules <code>isLazy()</code> is for maintaining a trace or log of all transformation steps, as redundant objects can act as a record of every individual transformation invocation, even if they are from the same input.</li> <li>Unique Lazy Rules (<code>isUniqueLazy()</code>): These are an enhanced version of the standard lazy rules. The primary distinction is their guarantee of execution uniqueness. If a unique lazy rule is called more than once with the same input elements, it ensures that the transformation occurs only once. This means that the result of the initial call is cached and reused for subsequent calls with identical inputs, preventing the generation of duplicate output elements. Unique lazy rules repurpose the declarative semantics of matched rules with a lazy evaluation strategy.</li> </ul> <p>A lazy rule, whether unique or non-unique, requires explicit invocation to produce an output element. This is executed by using the rule name using the fetch operation as follows:</p> <ul> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;)</code> for lazy rules with a single input object and multiple output objects.</li> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;, &lt;i&gt;)</code> for <code>toMany</code> lazy rules with a single input object and multiple output objects.</li> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;, &lt;argsMap&gt;)</code> for lazy rules with a single input object and multiple output objects that, in addition, are parameterized. <code>&lt;argsMap&gt;</code> is a map of type <code>Map&lt;String,Object&gt;</code>, where the keys are parameter names and the values are the actual parameter values.</li> </ul>"},{"location":"yamtl-reference.html#tomany-rules","title":"ToMany Rules","text":"<p>Matched rules can be declared with the modifier <code>toMany</code> to enable repeated rule applications to the same input object, using <code>toManyCap</code> to indicate how many rule applications should be performed. With <code>toMany</code> rules, the same rule might match the same object multiple times. In such cases, we can reference each match (occurrence 'i' of a match) by the order in which they occurred: <code>fetch(&lt;input_matched_object&gt;, &lt;i&gt;)</code> will return the output object created by the ith match.</p> <p>Declaring a rule with the modifier <code>toMany</code> adds the variable <code>matchCount</code> to the execution environment, which is used to distinguish the different rule applications starting from <code>0</code> for the first application. This variable is available during both pattern matching and transformation execution. This means that the variable <code>matchCount</code> can be used in filter expressions</p> <p>The property <code>toManyCap</code> receives a function of type <code>Supplier&lt;Integer&gt;</code>, which determines the total number of rule applications that should apply to the same match.</p> <p>When declaring rules using rule inheritance together with the modifier <code>toMany()</code>, all rules in the inheritance hierarchy must be <code>toMany()</code>.</p> <p>Differences with Lazy Rules</p> <p>A matched rule that is <code>toMany</code> is scheduled by the tranformation engine and not called on demand. However, when it is matched, the same match is associated with a list of rule applications. While the match is still unique for a particular rule, it is shared among several of the rule applications.</p>"},{"location":"yamtl-reference.html#rule-inheritance","title":"Rule Inheritance","text":"<p>Rule inheritance in YAMTL enables a transformation developer to create a new transformation rule by inheriting the behaviour of multiple existing rules. This mechanism simplifies the transformation process by allowing you to build on existing rule logic without duplicating code, promoting code reuse and encapsulation.</p> <p>The following characteristics define multiple rule inheritance in YAMTL:</p> <ul> <li>Abstract rules: Abstract rules are defined with the clause <code>.isAbstract()</code>. These rules typically act as templates or base rules that other rules can inherit from. These rules are not executed directly and their input/output pattern elements may refer to abstract classes.</li> <li>Concrete rules are rules that are executed if a valid match is found for the input pattern and the output pattern can only refer to concrete classes, i.e., those that can be instantiated in the output model.</li> <li>A descendant rule can inherit from one or several parent rules using the clause <code>inheritsFrom(&lt;ruleNameList&gt;)</code>, where <code>&lt;ruleNameList&gt;</code> is of type <code>List&lt;String&gt;</code>.</li> </ul> <p>When using rule inheritance, rules are expected to be covariant both in input elements and in output elements with respect to inheritance relationships in the corresponding metamodels. When an input or an output element is declared in a parent rule but not declared in a child rule, it is implicitly inherited. The semantics of a transformation rule with respect to inheritance is as follows: </p> <ul> <li>Pattern matching semantics. In matched input elements, filter expressions are inherited using a leftmost top-down evaluation strategy w.r.t. the inheritance hierarchy defined in clauses <code>inheritsFrom(&lt;ruleNameList&gt;)</code>. When an input element <code>in(\"&lt;in_object_name1&gt;\", &lt;in_object_type1&gt;).filter{ &lt;FILTER1&gt; }</code> is declared in a parent rule but it is not declared in a descendant rule, it is inherited. If the input element <code>in(\"&lt;in_object_name1&gt;\", &lt;in_object_type2&gt;).filter{ &lt;FILTER2&gt; }</code> is also defined in a descendant rule, <code>&lt;FILTER2&gt;</code> refines <code>&lt;FILTER1&gt;</code> by adding more constraints. In other words, both <code>&lt;FILTER1&gt;</code> and <code>&lt;FILTER2&gt;</code> must be satisfied by a match for the descendant rule. In addition, <code>&lt;in_object_type2&gt;</code> can be a subclass of <code>&lt;in_object_type1&gt;</code>. In derived input elements, derivation expressions (<code>derivedWith(&lt;QUERY&gt;)</code>) are overriden if they are declared in a descendant rule or simply inherited otherwise.  </li> <li>Transformation execution semantics. In output elements, action expressions are also inherited following a leftmost top-down evaluation strategy w.r.t. the inheritance hierarchy by default. When an output element <code>out(\"&lt;out_object_name&gt;\", &lt;out_object_type1&gt;, { &lt;ACTION1&gt; })</code> in a parent rule is refined by an output element <code>out(\"&lt;out_object_name&gt;\", &lt;out_object_type2&gt;, { &lt;ACTION2&gt; })</code> in a descendant rule, where <code>&lt;in_object_type2&gt;</code> may be a subclass of <code>&lt;in_object_type1&gt;</code>, then both <code>&lt;ACTION1&gt;</code> and <code>&lt;ACTION2&gt;</code> will be executed, in that order. The default behaviour can be overriden by using the qualifier <code>overriding()</code> in the corresponding output element of a descendant rule. When using <code>overriding()</code> in an output element, the parent action <code>&lt;ACTION1&gt;</code> is not executed.</li> </ul> <p>The following table summarizes the errors that YAMTL detects when parsing model transformation rules when rule inheritance is used:</p> Scope Error Description Explanation Resolution Rule Abstract Rule with No Children Rules An abstract rule should have at least one child rule. Define child rules for the abstract rule or consider making it non-abstract if no child rules are intended. Rule Concrete Rule Specialized by an Abstract Rule Occurs when a concrete rule is specialized by an abstract rule, which is not allowed. Ensure that concrete rules are not specialized by abstract rules. Input Incompatible Input Element Types Occurs when an input element's type in a descendant rule is not a subtype of the same input element's type in a parent rule. Make sure that the types of input elements in the descendant rule are compatible with those in the parent rule. Input Mismatched Nature of Input Elements Occurs when an input element's nature (matched/derived) differs between a rule and its parent rule. Ensure that the nature of input elements is consistent between the descendant rule and its parent rule. Input Input Element Inherited from Two Separate Parent Rules An input element cannot be inherited from two separate parent rules. Avoid inheriting the same input element from two separate parent rules to prevent conflicts. Output Output Element Declared as 'Overriding' with No Parent Rule Occurs when an output element is declared as 'overriding', but there is no parent rule to override. Remove the 'overriding' declaration or ensure that the rule has a valid parent rule. Output Incompatible Output Element Types Occurs when an output element's type in a descendant rule is not a subtype of the same output element's type in a parent rule. Ensure that the types of output elements in the descendant rule are compatible with those in the parent rule. Output Output Element Declared as 'Drop' with No Valid Input Element Occurs when an output element is declared as 'drop', but it does not refer to a valid input element. Check that the 'drop' declaration references a valid input element, or remove it if unnecessary. Output Output Element Inherited from Two Parent Rules with Different Types An output element cannot be inherited from two parent rules with incompatible types; this results in an error. Ensure that the types of inherited output elements are compatible between parent rules. Output Rule Inherits the Same Output Element from Two Parent Classes When a rule inherits the same output element from two parent classes, it's a potential issue, and a warning is issued. Review the rule's inheritance structure and consider if it leads to unintended behavior. <p>When a descendant rule inherits the same output element from two different parent rules, situation known as the diamond problem, YAMTL detects the situation and warns the user but the model transformation proceeds using inheritance semantics as explained above.</p> <p>Tip</p> <p>During pattern matching, YAMTL selects the most generic rules first. When a match is found for the parent rule, it then processes the match with the input pattern of the descendant rules using a depth-first strategy.</p> <p>Info</p> <p>In the original YAMTL semantics, YAMTL supported multiple rule inheritance in both input patterns and output patterns. Since version 0.3.6, multiple inheritance only applies to output patterns in rules. This feature has been deprecated to facilitate more concise syntax when specifying input patterns in rules.</p>"},{"location":"yamtl-reference.html#helpers","title":"Helpers","text":"<p>A helper in YAMTL streamlines the writing of transformation rules by offering reusable expressions. Think of it as creating utility functions or methods in conventional programming languages.</p> <p>In YAMTL, you can define helpers using standard constructs from the host programming language:</p> <ul> <li>Attributes with initialization expressions.</li> <li>Static operations that apply at the class level across all instances.</li> <li>Operations specific to objects.</li> </ul> <p>YAMTL further boosts these helpers' utility by caching their computations, optimizing runtime performance. Below, we present how to declare these helpers and call them in your transformations.</p>"},{"location":"yamtl-reference.html#attribute-helpers","title":"Attribute Helpers","text":"<p>The method <code>staticAttribute(\"&lt;name&gt;\", &lt;BODY&gt;)</code> creates an attribute <code>&lt;name&gt;</code>. Its value gets determined by the <code>&lt;BODY&gt;</code> expression, which must be of type <code>Supplier&lt;Object&gt;</code>.</p> <p>Attribute helpers shine when used with the <code>allInstances(&lt;EClass&gt;)</code> operation. This operation fetches a list containing all instances of the type <code>&lt;EClass&gt;</code> present in the input model. The expression <code>&lt;BODY&gt;</code> must return the value used to initialize the attribute, which can be an <code>EObject</code> or a primitive value.</p> GroovyXtendJavaKotlin <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", {  \n    // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n})\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", [|  \n    // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n])\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", new Supplier&lt;Object&gt;() {  \n    @Override\n    public Object get() {\n        // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n    }\n});\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\") {  \n    // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n}\n</code></pre> <p>An attribute helper can then be called by name. While the YAMTL Groovy DSL allows us to consider the attribute helper as a variable using its name (without the String quotes) directly, the operation <code>fetch</code> needs to be used in all other programming languages:</p> GroovyXtendJavaKotlin <pre><code>&lt;AttributeName&gt;\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre>"},{"location":"yamtl-reference.html#static-operation","title":"Static Operation","text":"<p>To manage static methods, YAMTL uses <code>staticOperation(\"&lt;name&gt;\", &lt;FUNCTION&gt;)</code> to define an operation <code>&lt;name&gt;</code> where <code>&lt;FUNCTION&gt;</code> is a lambda expression with a list of parameters specified as a map. The keys in the map are the names of the parameters, and the values are the actual arguments. Within the body of the lambda expression, you can access the arguments map using <code>argMap</code> and must ensure to return a value.</p> GroovyXtendJavaKotlin <pre><code>staticOperation(\"&lt;OperationName&gt;\", { argMap -&gt; \n    // returns the value of the parameter with name &lt;param_name&gt;\n    argMap.&lt;param_name&gt; \n})\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\", [ argMap | \n    // returns the value of the parameter with name &lt;param_name&gt;\n    argMap.get(\"&lt;param_name&gt;\")\n])\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\", argMap -&gt; {\n    // returns the value of the parameter with name &lt;param_name&gt;\n    return argMap.get(\"&lt;param_name&gt;\");\n});\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\") { argMap -&gt;\n    // returns the value of the parameter with name &lt;param_name&gt;\n    argMap[\"&lt;param_name&gt;\"]\n}\n</code></pre> <p>Static operations are invoked by their names and the list of arguments, specifying the name of the parameter and the actual argument value. While the YAMTL Groovy DSL allows calling the static operation directly, all other programming languages require the <code>fetch</code> operation:</p> GroovyXtendJavaKotlin <pre><code>&lt;OperationName&gt;([\"&lt;param1&gt;\" : &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", #[\"&lt;param1&gt;\" -&gt; &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", Map.of(\"&lt;param1&gt;\", &lt;value1&gt;, ...));\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", mapOf(\"&lt;param1&gt;\" to &lt;value1&gt;, ...))\n</code></pre>"},{"location":"yamtl-reference.html#contextual-operation","title":"Contextual Operation","text":"<p>To manage class methods, YAMTL uses <code>contextualOperation(\"&lt;name&gt;\", &lt;BIFUNCTION&gt;)</code> to define an operation <code>&lt;name&gt;</code> where <code>&lt;BIFUNCTION&gt;</code> is a lambda expression with two parameters: the contextual instance or object to which the operation is applied, and list of parameters specified as a map. The keys in the map are the names of the parameters, and the values are the actual arguments. Within the body of the lambda expression, you can access the contextual instance or the arguments map, and must ensure to return a value, either an <code>EObject</code> or a primitive value.</p> GroovyXtendJavaKotlin <pre><code>contextualOperation(\"&lt;OperationName&gt;\", { obj, argMap -&gt; \n    // to access the contextual instance use 'obj' \n    // to access an argument use 'argMap.&lt;param_name&gt;' \n    // must return a value\n})\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\", [ obj, argMap | \n    // to access the contextual instance use 'obj' \n    // to access an argument use 'argMap.get(\"&lt;param_name&gt;\")' \n    // must return a value\n])\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\", (obj, argMap) -&gt; {\n    // to access the contextual instance use 'obj'\n    // to access an argument use 'argMap.get(\"&lt;param_name&gt;\")'\n    // must return a value\n});\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\") { obj, argMap -&gt;\n    // to access the contextual instance use 'obj'\n    // to access an argument use 'argMap[\"&lt;param_name&gt;\"]'\n    // must return a value\n}\n</code></pre> <p>Contextual operations are invoked on the <code>&lt;ContextualInstance&gt;</code> using the <code>&lt;OperationName&gt;</code> and the list of arguments, specifying the name of the parameter and the actual argument value. While the YAMTL Groovy DSL allows calling the  operation directly, all other programming languages require the <code>fetch</code> operation:</p> GroovyXtendJavaKotlin <pre><code>&lt;OperationName&gt;(&lt;ContextualInstance&gt;, [\"&lt;param1&gt;\" : &lt;value1&gt;, ...])\n</code></pre> <pre><code>&lt;ContextualInstance&gt;.fetch(\"&lt;OperationName&gt;\", #[\"&lt;param1&gt;\" -&gt; &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(&lt;ContextualInstance&gt;, \"&lt;OperationName&gt;\", Map.of(\"&lt;param1&gt;\", &lt;value1&gt;, ...));\n</code></pre> <pre><code>fetch(&lt;ContextualInstance&gt;, \"&lt;OperationName&gt;\", mapOf(\"&lt;param1&gt;\" to &lt;value1&gt;, ...))\n</code></pre>"},{"location":"yamtl-reference.html#commands","title":"Commands","text":""},{"location":"yamtl-reference.html#fetch","title":"<code>fetch()</code>","text":"<p>The fetch operation in YAMTL, <code>YAMTLModule::fetch()</code>, is used to retrieve output objects that correspond to given input objects through the application of transformation rules. The main purpose of <code>fetch()</code> is to resolve references to output objects that are created by other rules. Since rules in YAMTL transformations execute independently, they cannot directly access the output objects produced by other rules. The fetch operation serves as a bridge to connect these separate rule contexts.</p> <p>When a rule's action needs to reference an output element initialized by another rule, it uses fetch with the input object to look up the corresponding output object. For example, <code>fetch(input_object)</code> returns the output object created by the rule that matched <code>input_object</code>.</p>"},{"location":"yamtl-reference.html#multiple-elements-in-the-input-pattern","title":"Multiple elements in the Input Pattern","text":"<p>When the input pattern contains more than one element, instead of using one single input object, a valid match must be provided by using a map where the keys are <code>&lt;in_object_name&gt;</code>s and the values are the matched <code>EObject</code>s. The match must contain an <code>in</code> element for each <code>in</code> object patterns in the input pattern of the rule.</p> GroovyXtendJavaKotlin <pre><code>fetch(['in_var1': eObject1, 'in_var2': eObject2, ...])\n</code></pre> <pre><code>fetch(#{'in_var1' -&gt; eObject1, 'in_var2'-&gt; eObject2, ...})\n</code></pre> <pre><code>fetch(Map.of(\"in_var1\", eObject1, \"in_var2\", eObject2, ...))\n</code></pre> <pre><code>fetch( mapOf(\"in_var1\" to eObject1, \"in_var2\" to eObject2, ...) )\n</code></pre>"},{"location":"yamtl-reference.html#multiple-elements-in-the-input-pattern-in-multi-model-transformations","title":"Multiple Elements in the Input Pattern in Multi-Model Transformations","text":"<p>When specifying input patterns across domains in multi-model transformations, you can resolve output objects by presenting <code>fetch()</code> with a set of matches, specifying lists of objects for each domain in the match. <code>fetch()</code> will internally apply pattern matching with transformation rules in the rule store and return a list of objects for the default output variable. Refer to the next section for cases where there is more than one <code>out</code> variable.</p> GroovyXtendJavaKotlin <pre><code>fetch(['in_var1': [eObject1, ...], 'in_var2': [eObject2, ...], ...])\n</code></pre> <pre><code>fetch(#{'in_var1' -&gt; #[eObject1, ...], 'in_var2' -&gt; #[eObject2, ...], ...})\n</code></pre> <pre><code>fetch(Map.of(\n    \"in_var1\", List.of(eObject1, ...),\n    \"in_var2\", List.of(eObject2, ...),\n    ...\n));\n</code></pre> <pre><code>fetch(\n    mapOf(\n        \"in_var1\" to listOf(eObject1, ...),\n        \"in_var2\" to listOf(eObject2, ...),\n        ...\n    )\n)\n</code></pre>"},{"location":"yamtl-reference.html#multiple-elements-in-the-output-pattern","title":"Multiple Elements in the Output Pattern","text":"<p>When the output pattern comprises several object patterns, it's necessary to specify which output element we wish to fetch: <code>fetch(&lt;input_matched_object&gt;, \"&lt;out_var_name&gt;\")</code> will return the output object linked to the output element <code>outVarName</code>. If a matched rule with a complex output pattern also uses the <code>toMany</code> declaration, the output object can be retrieved with <code>fetch(&lt;input_matched_object&gt;, \"&lt;out_var_name&gt;\", &lt;i&gt;)</code>.</p>"},{"location":"yamtl-reference.html#calling-lazy-rules","title":"Calling Lazy Rules","text":"<p>The fetch operation is the only mechanism available to execute lazy rules, as explained in the subsection Lazy Rules.</p>"},{"location":"yamtl-reference.html#calling-helpers","title":"Calling Helpers","text":"<p>In JVM languages, other than Groovy, the fetch operation is also used to call helpers, as explained in the subsection Helpers.</p>"},{"location":"yamtl-reference.html#handling-tomany-rules","title":"Handling ToMany Rules","text":"<p>ToMany rules can be applied to the same input object multiple times. In such cases, we can retrieve the output objects obtained in each rule application using the operation fetch(), as explained in the subsection ToMany Rules.</p>"},{"location":"yamtl-reference.html#variables-in-execution-context","title":"Variables in Execution Context","text":"<p>In JVM languages, other than Groovy, the fetch operation is also used to call helpers, fetch variables from the execution environment, with the expression <code>fetch(\"&lt;variable-name&gt;\")</code>.</p>"},{"location":"yamtl-reference.html#allinstanceseclass","title":"<code>allInstances(EClass)</code>","text":"<p>The <code>allInstances(&lt;typeName&gt;)</code> operation is used to create OCL-like queries in lambda expressions and can be invoked in any of the following expressions: <code>&lt;FILTER&gt;</code>, <code>&lt;QUERY&gt;</code>, and <code>&lt;ACTION&gt;</code>.</p> <p><code>allInstances(&lt;typeName&gt;)</code> returns the collection of objects of type <code>&lt;typeName&gt;</code> in the input model. In multi-model transformations, it is necessary to specify the <code>&lt;domainName&gt;</code> of the corresponding domain <code>in</code> or <code>inOut</code> in the transformation header, as follows: <code>allInstances(&lt;domainName&gt;, &lt;typeName&gt;)</code>. This retrieves a collection of objects of type <code>&lt;typeName&gt;</code> from the domain <code>&lt;domainName&gt;</code> only. </p> <p>Note that <code>out</code> domains cannot be queried with <code>allInstances()</code>. Output objects can only be fetched via the operator <code>fetch()</code>.</p>"},{"location":"yamtl-reference.html#module-composition","title":"Module Composition","text":"<p>YAMTL modules can be imported and used in other Xtend/Java/Groovy classes by creating instances of their main classes. This allows you to reuse the functionality provided by a YAMTL module within your code. A YAMTL module can also incorporate any Java Virtual Machine (JVM) library, extending its functionality by using external code.</p> <p>Module extension is used for composing modules i.e. creating a subclass of an existing module to extend the capabilities of the base module. When YAMTL modules are extended, the process of initializing rules and attribute helpers begins from the root modules (those that do not extend any other module). Initialization then proceeds along the hierarchy of extended modules, moving from parent modules to their descendants.</p> <p>When a specializing module declares a rule that is already defined in the parent module (by name), the new rule overrides the existing one. Rules in the parent module can also be extended using rule inheritance.</p>"},{"location":"yamtl-reference.html#incremental-model-to-model-transformations","title":"Incremental Model-to-Model Transformations","text":"<p>By default model-to-model transformations in YAMTL transformations are executed in batch mode, where the entire input model is read and a new output model is produced from scratch. However, this approach can be inefficient when dealing with large models or when only a small portion of the model undergoes changes. To address this limitation, incremental model-to-model transformations have emerged as a more efficient alternative.</p> <p>Incremental model-to-model transformations in YAMTL extend the capabilities of standard transformations by maintaining a relationship between the source and target models. Rather than reprocessing the entire model, these transformations update only the parts of the target model that correspond to changed elements in the source model. This results in an increase in computational efficiency, particularly in scenarios where models are large, or changes are frequent but localized. </p> <p>Incremental transformations are commonly used in the following scenarios:</p> <ul> <li>Real-Time Systems: In real-time systems where immediate responsiveness is essential, incremental transformations can deliver results more rapidly.</li> <li>Collaborative Modeling: In environments where multiple individuals are modifying a model simultaneously, incremental transformations help maintain a coherent and updated version of the target model.</li> <li>Continuous Integration: Incremental transformations are beneficial for continuous development pipelines that require constant model updates.</li> </ul> <p>YAMTL support for the incremental evaluation of model transformations relies on the following components:</p> <ul> <li>Tracking transformation steps. Every application of a transformation rule to an input model constitutes a transformation step, which associates an input match with a corresponding output match.  In YAMTL, this tracking occurs implicitly, eliminating the need for user-initiated manual intervention. YAMTL also supports explicit mechanisms for tracking transformation steps.</li> <li>Tracking feature calls. Structural features in the input model, typically corresponding to objects matched by the input pattern of a rule, are employed for computations within <code>&lt;FILTER&gt;</code>, <code>&lt;QUERY&gt;</code>, or <code>&lt;ACTION&gt;</code> blocks. YAMTL can identify the usage of an accessor method that commences with the get prefix to access a structural feature of an object in the input model. This detection is facilitated through aspect-oriented programming. To enable this functionality, the user must configure the YAMTLModule with the namespace containing the input model's classes. This is accomplished via the configuration option xform.adviseWithinThisNamespaceExpressions(<code>&lt;namespaceList&gt;</code>);, where xform is the YAMTLModule containing rule definitions, and <code>&lt;namespaceList&gt;</code>, of type <code>List&lt;String&gt;</code>, enumerates the namespaces to be instrumented with aspects. A namespace may be specified as a fully qualified package name, such as com.a.y, or may encompass a set of packages using <code>..*</code>, like  <code>com.a.y.*</code>, which includes package <code>com.a.y</code> and its direct subpackages, or <code>com.a.y..*</code>, which includes package <code>com.a.y</code> and all its subpackages.</li> <li>Tracking changes in a model. Model changes can be classified into two categories: on-the-fly and offline changes. On-the-fly changes involve real-time modifications to the objects within a model in memory, whereas offline changes pertain to the application of a distinct model describing these alterations. YAMTL employs the EMF Adapter Framework for handling on-the-fly modifications, and utilises the EMF Change Model for processing offline changes. The EMF Change Model is equipped with a change recorder that is capable of serialising the in-memory change description model in XMI format.</li> </ul> <p>The execution of an incremental model transformation in YAMTL is performed in two stages:</p> <ul> <li>Initial stage. The model transformation is executed in batch mode and YAMTL stores transformation steps.</li> <li>Change propagation stage. Given a source model change (either on-the-fly or offline), YAMTL analyses the impact of the change on the model transformation and only re-evaluates those transformation steps that are affected.</li> </ul>"},{"location":"yamtl-reference.html#template-to-execute-model-transformations","title":"Template to execute model transformations","text":"<p>The following example code snippets illustrate how to configure and execute a transformation in YAMTL using different programming languages.</p>"},{"location":"yamtl-reference.html#using-on-the-fly-changes","title":"Using On-the-Fly Changes","text":"<p>The code snippets below ilustrate how to execute a model transformation in incremental mode, making a change to the input model once it has been transformed with <code>YAMTLModule::execute()</code>. </p> GroovyXtendJavaKotlin <pre><code>// CONFIGURATION\ndef xform = new XForm()\nYAMTLGroovyExtensions.init(this)        \nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\")\n/* CHANGES TO MODEL HERE */\nxform.propagateDelta(\"&lt;in_domain_name&gt;\")\nxform.saveOutputModels([\"&lt;out_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>// CONFIGURATION\nval xform = new XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(#{'&lt;in_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n// INITIAL TRANSFORMATION\nxform.execute\n// DELTA PROPAGATION\nxform.adaptInputModel('&lt;in_domain_name&gt;')\n// CHANGES TO MODEL HERE\nxform.propagateDelta('&lt;in_domain_name&gt;')\nxform.saveOutputModels(#{'&lt;out_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n</code></pre> <pre><code>// CONFIGURATION\nXForm xform = new XForm();\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.setExecutionMode(ExecutionMode.INCREMENTAL);\nxform.loadInputModels(Map.of(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n// INITIAL TRANSFORMATION\nxform.execute();\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\");\n// CHANGES TO MODEL HERE\nxform.propagateDelta(\"&lt;in_domain_name&gt;\");\nxform.saveOutputModels(Map.of(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>// CONFIGURATION\nval xform = XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.setExecutionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\")\n// CHANGES TO MODEL HERE\nxform.propagateDelta(\"&lt;in_domain_name&gt;\")\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>Incremental transformations are activated by setting the execution mode to <code>ExecutionMode.INCREMENTAL</code>.</p> <p>The YAMTL engine is instructed on the locations for instrumenting <code>getter</code> methods through the statement <code>xform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)</code>, specifying the pertinent package names.</p> <p>For change tracking, the <code>xform.adaptInputModel(\"&lt;in_domain_name&gt;\")</code> statement is used to instrument the input model with EMF adapters. It is important to abstain from adapting the model prior to invoking <code>execute()</code>, in order to minimise the extent of changes requiring monitoring. Changes are made by accessing objects in the <code>Resource</code> of the input model, which can be accessed using <code>xform.getModelResource(\"&lt;in_domain_name&gt;\")</code>, and applying changes to their structural features.</p> <p>Subsequently, the <code>xform.propagateDelta(\"&lt;in_domain_name&gt;\")</code> statement facilitates the propagation of any changes made from the input model to the output model.</p>"},{"location":"yamtl-reference.html#using-offline-changes","title":"Using Offline Changes","text":"GroovyXtendJavaKotlin <pre><code>// CONFIGURATION\ndef xform = new XForm()\nYAMTLGroovyExtensions.init(this)        \nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels([\"&lt;out_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>// CONFIGURATION\nval xform = new XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(#{'&lt;in_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n// INITIAL TRANSFORMATION\nxform.execute\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels(#{'&lt;out_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n</code></pre> <pre><code>// CONFIGURATION\nXForm xform = new XForm();\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.setExecutionMode(ExecutionMode.INCREMENTAL);\nxform.loadInputModels(Map.of(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n// INITIAL TRANSFORMATION\nxform.execute();\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\");\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\");\nxform.saveOutputModels(Map.of(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>// CONFIGURATION\nval xform = XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>The primary distinction when employing offline changes lies in the provision of changes to the input model via a change description model, as defined by the EMF Change Model<sup>1</sup>. The statement <code>xform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")</code> loads the change stored at <code>&lt;path/to/delta/file.xmi&gt;</code>, subsequently associating it with the input model identified by <code>&lt;in_domain_name&gt;</code> and a user-defined name <code>&lt;deltaName&gt;</code>.</p> <p>For the propagation of this change, it first needs to be applied to the input model and then needs to be propagated to the output model. This is achieved via the statement <code>xform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")</code>.</p>"},{"location":"yamtl-reference.html#incrementality-granularity","title":"Incrementality granularity","text":"<p>YAMTL is an internal DSL of JVM programming languages and specific design decisions have been made in order to reuse as much syntax from the underlying host programming language as possible. In particular, assignments of values to object features (attributes and references) are handled by the assignment statement in the host language.</p> <p>In general terms, YAMTL checks whether a change invalidates the match of an existing transformation step. If the match is no longer valid, the transformation step is undone. Otherwise, the transformation step will be re-executed according to the following levels of granularity:</p> <ul> <li>Tranformation step granularity (<code>IncrementalGranularity.TRAFO_STEP</code>): When a change impacts any part of a transformation step, the match whole transformation step is re-executed. This is the default granularity level.</li> <li>Element granularity (<code>IncrementalGranularity.ELEMENT</code>): This is a more refined mode in which YAMTL detects whether a change only affects a particular <code>in</code> or <code>out</code> element. YAMTL only re-evaluates the filters of affected <code>in</code> elements and the actions of affected <code>out</code> elements.</li> </ul> <p>The granularity of the incremental evaluation scope is set using the flag <code>YAMTLModule::incrementalGranularity</code>. By default, it is set to <code>IncrementalGranularity.TRAFO_STEP</code> and it can be set to <code>IncrementalGranularity.ELEMENT</code>.</p>"},{"location":"yamtl-reference.html#undo","title":"Undo","text":"<p>Todo</p>"},{"location":"yamtl-reference.html#implicit-vs-explicit-traceability","title":"Implicit vs explicit traceability","text":"<p>Todo</p>"},{"location":"yamtl-reference.html#examples","title":"Examples","text":"<ul> <li> <p>The Linked list reversal example reverses a linked list data structure originally stored in XMI format (source model). YAMTL transformation generates an <code>outputList.xmi</code> containing the target model. Both source and target metamodels are created using the same ECore file since the data structure remains the same after the transformation. A Gradle test runs a Groovy script that loads the input model, executes the transformation, and saves the output model.</p> </li> <li> <p>Flowchart to HTML project looks at transforming flowchart models into valid HTML documents. This project specifically has multiple transformation examples that cover a wide range of YAMTL operations, annotations, and core concepts. This project is perfect for readers who want to take the next step in learning more about the complete functionality of each MTL tool in well-documented bite-sized examples.</p> </li> </ul>"},{"location":"yamtl-reference.html#trade-offs-regarding-performance","title":"Trade-offs regarding performance","text":"<p>Todo</p> <ul> <li>Groovy vs Xtend/Java: Groovy offers a more readable syntax</li> <li>SpringAOP vs AspectJ: SpringAOP simplifies configuration</li> </ul> <ol> <li> <p>David Steinberg, Frank Budinsky, Marcelo Paternostro, and Ed Merks. 2009. EMF: Eclipse Modeling Framework 2.0 (2nd. ed.). Addison-Wesley Professional.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/ep-inspection.html","title":"Analysis of Activity Configurations for the Education Platform","text":"<p>The MDENet education platform aims to allow users to quickly start learning fundamental model-driven engineering techniques via a web browser. Learning activities are defined via configuration files that consist of two parts, tool identification and specification of activity:</p> <ul> <li>Tool specification: references the API specification of a specific MDE tool to be used in a learning activity.</li> <li>Activity specification: defines the specific UI elements and action buttons available to the user and what they do. What panes are available and what additional configuration information they require, depends on the tools being used.</li> </ul> <p>In this example, we illustrate how to use YAMTL to import activity configurations, available as YAML or JSON files, as flexible models in order to transform them to metamodel-based models so that they can be visuallized and analyzed. YAMTL model queries are used to inspect them, aiding in both understanding and debugging. </p> <p>Education platform configuration files can be inspected with YAMTL interactively via \ud83d\udd0d this activity on the education platform itself.</p>"},{"location":"examples/ep-inspection.html#importing-activity-configurations-as-models","title":"Importing Activity Configurations as Models","text":"<p>Activity and tool specifications are defined using YAML or JSON configuration files that specify the layout of the front-end UI and the examples used in the activities, according to the configuration language below. </p> <p></p> <p>The activity shown in the screenshot below displays the YAML configuration file (1) of this activity, the YAMTL model transformation (3) from the YAML/JSON (1) file to a model (2) that conforms to the education platform activity language (5), shown above, converting references by name in the YAML configuration file to references by value in the model. </p> <p></p> <p>The left-hand side panel can display multiple activities when included in the same configuration file. Consequently, these configurations can become lengthy and challenging to debug, more so considering that YAML does not enforce a data schema. The benefit of this activity is that activity configurations can be treated as flexible models using YAMTL in order to transform them to statically-typed models that can be visualized as object graphs using object diagram notation, as shown in the composite panel (2).</p>"},{"location":"examples/ep-inspection.html#activity-configuration-analysis","title":"Activity Configuration Analysis","text":"<p>This example uses YAMTL model queries (6) for defining object-oriented queries over models built atop the YAMTL pattern matcher. </p> <p>Queries are defined as records, resembling JSON documents, with the following fields: </p> <ul> <li>a <code>context</code> type from the metamodel (5); </li> <li>a <code>where</code> Groovy closure that specifies which objects from the model (2) are affected by the query; and </li> <li>a <code>query</code> Groovy closure that traverses the model from an instance of the <code>context</code> type, printing the desired information in the output stream, which is displayed on the console (4). </li> </ul> <p>The query in the example finds out how the activity actions prompt UI state changes, by listing the <code>source-panel</code> containing the action, the button linked to the action, the argument binding for the parameters of the MDE tool linked to the action, and the <code>target-panel</code> containing the results of the tool and any additional <code>output</code> side effects, using the format <code>source-panel |-{ button(parameter-binding)}-&gt; target-panel [output]</code>. In this query, when the button identifier cannot be resolved, <code>MISSING</code> is displayed to report an error.</p> <p>\ud83d\udd0d This interactive activity shows an example where the tool specification is missing and one where the tool specification is provided.</p>"},{"location":"examples/ep-inspection.html#wrap-up","title":"Wrap-up","text":"<p>This example shows how to import YAML/JSON activity configurations as flexible models in YAMTL. The transformation from flexible configuration models to metamodel-based configuration models enables easier visualization and analysis, allowing seamless combination with other MDE tools and simplifying the process of defining and debugging new learning activities collaboratively via the education platform.</p>"},{"location":"examples/examples.html","title":"Examples","text":"<p>Several examples are available in this repository.</p>"},{"location":"examples/flexible-models.html","title":"Transformations with Flexible Models","text":"<p>Flexible models allow for the transformation of semi-structured data, which combines structured elements (like tags) with unstructured components (like free text) without adhering to a fixed schema (or metamodel). This flexibility is beneficial in fields like big data and data integration, enabling the handling of diverse data sources without schema constraints.</p> <p>In this example, we show how to load CSV data as a flexible model and how to transform it to a metamodel-based model.</p>"},{"location":"examples/flexible-models.html#semi-structured-data","title":"Semi-structured Data","text":"<p>Semi-structured data combines elements of structure, like tags, with unstructured components such as free text, without adhering to a fixed schema like a metamodel. This flexibility is beneficial in fields like big data and data integration, enabling the handling of diverse data sources without schema constraints. Despite its versatility, semi-structured data lacks the rigor of structured data models, which facilitate processing, manipulation, and analysis using Model-Driven Engineering (MDE) techniques.</p> <p>It is common to encounter datasets that are stored in semi-structured formats, such as CSV files. The dataset in Table 1 represents a collection of physical activity data recorded for a group of patients. The data includes information about the date, time, distance, intensity, air quality, air temperature, and heart rate of each physical activity performed by the patients. This is an example where the dataset consists of plain tuples, where there are no further relationships between fields of the tuple other than belonging to the tuple. The dataset contains examples of heterogeneous data, with intensity and air quality measured using different scales and variations in date format and units of measurement for distance and temperature. Additionally, inconsistencies exist in the formatting of the data, with air temperature sometimes not written consistently and the blank space between figures and units occasionally missing. Furthermore, the dataset includes gaps that indicate a lack of data for certain fields.</p> Patient ID Date Time Distance Intensity Air Quality Air Temperature Heart Rate (bpm) 1 01/03/2023 10:00 2.5 miles Moderate Good 20 C 72 1 01/03/2023 11:00 3.0 miles High Excellent 22C 78 1 March 2023 10:00 1.5 km 2 1 2 1 March 2023 11:00 2.0 km 3 68 F"},{"location":"examples/flexible-models.html#flexible-models","title":"Flexible Models","text":"<p>To enable the use of flexible models, we define a metamodel that can represent the structure of models that do not have a fixed metamodel. This allows us to handle semi-structured data within MDE frameworks. The metamodel consists of the following main elements:</p> <ul> <li>UntypedModel: Represents the overall model.</li> <li>ERecord: Represents an instance of a semi-structured <code>EObject</code>.</li> <li>RecordField: Abstract class representing a field of an <code>ERecord</code>, either an AttributeField containing a value, a ReferenceField referring to other <code>ERecord</code>s, or a ContainmentField containing other <code>ERecord</code>s.</li> </ul> <p>The class diagram below illustrates the metamodel for flexible models for presentation purposes. </p> <p></p> <p>The <code>ERecord</code> class offers a dynamically-typed interface that provides accessor and mutator methods that encapsulate its implementation. Accessor methods define how to retrieve field values. The accessor <code>get(fieldName)</code> returns the value of a field <code>fieldName</code> as a Java Object. Since the semi-structured model operates with the absence of metamodel information, there is a mutator operation for each type of field, with upsert semantics. That is, whenever a mutator operation is called, it either inserts the field value if not present in the <code>ERecord</code> and, if present, it overrides it. These accessor/mutator methods are implemented both as static methods of the class <code>ERecordUtil</code> so that languages like Xtend can use static extensions, and as methods of the the specialized class <code>ERecordImplAccessors</code> of <code>ERecord</code> (i.e. of <code>ERecordImpl</code> in the generated EMF code) so that languages like Java can use them.</p> <p>The <code>UntypedModel</code> class serves as an intermediary abstraction layer between databinding libraries and model management APIs. This layer offers several design benefits:</p> <ul> <li>Decoupling Data Sources: Enables extraction of semi-structured data from various heterogeneous sources in a unified way.</li> <li>Modular Design: Encapsulates design concerns common across various semi-structured data sources.</li> <li>Consistent Performance: Ensures consistent performance across different data sources by providing a common interface.</li> <li>Interoperability: Enables interaction at an object-level without relying on extraneous third-party APIs.</li> </ul> <p>The <code>UntypedModel</code> import/export methods are used internally and they are used from the YAMTL I/O interface <code>loadInputModel</code> and <code>saveOutputModels</code>, as shown below. </p>"},{"location":"examples/flexible-models.html#transforming-semi-structured-data","title":"Transforming Semi-Structured Data","text":"<p>The goal of this example is to transform raw and semi-structured data into a more meaningful and structured model. We will be transforming a CSV dataset into an instance of the following metamodel <code>PA</code> describing physical activities recorded for patients.</p> <p></p> <p>The following example demonstrates how to define a transformation to convert semi-structured data into a structured model using YAMTL:</p> <pre><code>header().in('csv').out('pa', PA)\n\nruleStore([\n    rule('Activity')\n        .in('r')\n        .out('a', PA.physicalActivity) {\n            def p = getPatient(['patient_id' : r.patient_id])\n            p.activities += a\n\n            def date = r.date\n            def time = r.time\n            def dateFormat = new SimpleDateFormat(\"MM/dd/yyyy HH:mm\")\n            a.date = dateFormat.parse(date + \" \" + time)\n            a.duration = r.duration_minutes.toInteger()\n            a.distance = r.distance_km.toDouble()\n            a.intensity = Intensity.get(r.intensity)\n            a.airCondition = AirCondition.get(r.air_condition)\n            a.airQuality = AirQuality.get(r.air_quality)\n        }\n])  \n\nhelperStore([\n    staticOperation('getPatient') { \n        def p = PAFactory.createPatient()\n        p.patientID = Integer.valueOf(patient_id)\n        p\n    }\n])\n</code></pre> <p>In the transformation header, the dataset is loaded as an untyped model using the domain name <code>csv</code>, without specifying any metamodel. The output domain corresponds to the metamodel <code>PA</code> shown above, so the model transformation will create models conforming to this metamodel. <code>PA</code> must be the EPackage containing the declaration of the metamodel classifiers.</p> <p>In the rule <code>Activity</code>, the MT assumes that each row of a dataset is available in memory as an <code>ERecord</code>, by not specifying the type of the <code>in</code> element <code>r</code>. The rule matches each row in the dataset and creates <code>Patient</code> and <code>PhysicalActivity</code> instances. Each row is translated into a <code>PhysicalActivity</code> instance, and each unique <code>patient_id</code> in a row gives rise to a <code>Patient</code> instance that is related to the <code>PhysicalActivity</code> instance corresponding to the row. </p> <p>The static operation <code>getPatient</code> retrieves the argument <code>patient_id</code> from the execution context using the parameter name and returns a new <code>Patient</code> instance. Static operations cache the result for each unique invocation, ensuring that only one <code>Patient</code> instance is created for each <code>patient_id</code>.</p>"},{"location":"examples/flexible-models.html#running-the-transformation","title":"Running the Transformation","text":"<p>The transformation is executed with the usual steps:</p> <pre><code>val xform = new CSV2PA()\nYAMTLGroovyExtensions.init(xform) // to load Groovy extensions\nxform.loadInputModels(['csv': 'path/to/input.csv'])\nxform.execute()\nxform.saveOutputModels(['pa': 'path/to/output.xmi'])\n</code></pre> <p>The methods <code>loadInputModels</code>/<code>saveOutputModels</code> from the <code>YAMTLModule</code> I/O interface will select the right data conversion based on the given file extension:</p> <ul> <li><code>csv</code>, <code>json</code>, <code>yml</code>, <code>xml</code> are associated with the metamodel of flexible models described above,</li> <li><code>xmi</code> is assumed to correspond to an EMF model whose metamodel has already been loaded.</li> </ul> <p>The code for the transformation below can be found here (<code>src/main/groovy/flexibleModels</code> contains the definition of transformations and <code>src/test/groovy/flexibleModels</code> how to execute them with some example models).</p>"},{"location":"examples/flowchart-to-html-example.html","title":"Flowchart to HTML","text":""},{"location":"examples/flowchart-to-html-example.html#problem-description","title":"Problem Description","text":"<p>In this example, we will look at converting flowchart elements into HTML elements. The problem is open-ended, meaning, there is no one solution but rather the project will contain many small examples that showcase a multitude of operations for each documented MTL. The flowchart which should be used as the source model of the project is depicted in the diagram below:</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>Here is how the different models in this project depend on each other:</p> <p><pre><code>graph BT\n    B[Source Model] --&gt;|conforms to| A[Flowchart Metamodel];\n    C[MT Execution Engine] --&gt;|reads| B;\n    C --&gt;|executes| D[MT Definition];\n    C --&gt;|writes| E[Target Model];\n    D --&gt;|uses| A;\n    E --&gt;|conforms to| F[HTML Metamodel];\n    D --&gt;|uses| F;</code></pre> </p> Dependencies of the project files <p>Now, let's see how the models are defined.</p>"},{"location":"examples/flowchart-to-html-example.html#source-metamodel","title":"Source Metamodel","text":"<p>The source metamodel is defined using Emfatic (.emf), which can be converted into an <code>ECore</code> file. You can then access the flowchart classes as <code>EPackage</code>s (<code>ECore</code> has <code>EClasses</code> which are referenced as <code>EPackage</code> in Groovy) to be used within the MT definition. </p> <pre><code>@namespace(uri=\"flowchart\", prefix=\"flowchart\")\npackage flowchart;\n\nabstract class NamedElement {\n    attr String name;\n}\n\nclass Flowchart extends NamedElement {\n   val Node[*] nodes;\n   val Transition[*] transitions;\n}\n\nabstract class Node extends NamedElement {\n   ref Transition[*]#source outgoing;\n   ref Transition[*]#target incoming;\n}\n\nclass Transition extends NamedElement {\n   ref Node#outgoing source;\n   ref Node#incoming target;\n}\n\nclass Action extends Node {\n\n}\n\nclass Decision extends Node {\n\n}\n\nclass Subflow extends Flowchart, Node {\n\n}\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#target-metamodel","title":"Target Metamodel","text":"<p>Just like before, the target metamodel is also defined using Emfatic. The metamodel script is long because all HTML elements must be defined so that the transformation generates a valid HTML document.</p> <pre><code>package HTML;\n\n  class HTML {\n    !ordered val HEAD#html head;\n    !ordered val BODY#html body;\n  }\n\n  class HTMLElement {\n    !unique !ordered attr EString value;\n    !ordered val HTMLElement[*] children;\n  }\n\n  class HEAD extends HTMLElement {\n    !ordered val HEADElement[*]#head headElements;\n    !ordered ref HTML#head html;\n  }\n\n  abstract class HEADElement extends HTMLElement {\n    !ordered ref HEAD#headElements head;\n  }\n\n  class LINK extends HEADElement {\n    !unique !ordered attr EString rel;\n    !unique !ordered attr EString title;\n    !unique !ordered attr EString ahref;\n    !unique !ordered attr EString type;\n  }\n\n  class TITLE extends HEADElement {\n  }\n\n  class BODY extends HTMLElement {\n    !unique !ordered attr EString background;\n    !unique !ordered attr EString bgcolor;\n    !unique !ordered attr EString text;\n    !unique !ordered attr EString link;\n    !unique !ordered attr EString alink;\n    !unique !ordered attr EString vlink;\n    !ordered val BODYElement[*] bodyElements;\n    !ordered ref HTML#body html;\n  }\n\n  abstract class BODYElement extends HTMLElement {\n  }\n\n  class H1 extends BODYElement {\n  }\n\n  class H2 extends BODYElement {\n  }\n\n  class H3 extends BODYElement {\n  }\n\n  class H4 extends BODYElement {\n  }\n\n  class EM extends BODYElement {\n  }\n\n  class STRONG extends BODYElement {\n  }\n\n  class B extends BODYElement {\n  }\n\n  class I extends BODYElement {\n  }\n\n  class TT extends BODYElement {\n  }\n\n  class PRE extends BODYElement {\n  }\n\n  class BIG extends BODYElement {\n  }\n\n  class SMALL extends BODYElement {\n  }\n\n  class SUB extends BODYElement {\n  }\n\n  class SUP extends BODYElement {\n  }\n\n  class STRIKE extends BODYElement {\n  }\n\n  class FONT extends BODYElement {\n    !unique !ordered attr EString color;\n    !unique !ordered attr EString face;\n    !unique !ordered attr EString size;\n  }\n\n  class IMG extends BODYElement {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n    !unique !ordered attr EString alt;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString vspace;\n    !unique !ordered attr EString hspace;\n    !unique !ordered attr EString ismap;\n    !unique !ordered attr EString usemap;\n    !unique !ordered attr EString border;\n  }\n\n  class BR extends BODYElement {\n    !unique !ordered attr EString clear;\n  }\n\n  class MAP extends BODYElement {\n  }\n\n  class AREA extends BODYElement {\n    !unique !ordered attr EString shape;\n    !unique !ordered attr EString coords;\n    !unique !ordered attr EString ahref;\n  }\n\n  class STYLE extends BODYElement {\n  }\n\n  class EMBED extends BODYElement {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString vspace;\n    !unique !ordered attr EString hspace;\n    !unique !ordered attr EString border;\n  }\n\n  class NOEMBED extends BODYElement {\n  }\n\n  class SPAN extends BODYElement {\n    !unique !ordered attr EString style;\n  }\n\n  class A extends BODYElement {\n    !unique !ordered attr EString ahref;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString ~id;\n  }\n\n  class DIV extends BODYElement {\n    !unique !ordered attr EString align;\n  }\n\n  class P extends BODYElement {\n  }\n\n  abstract class TABLEElement extends BODYElement {\n    !unique !ordered attr EString bgcolor;\n    !unique !ordered attr EString background;\n  }\n\n  class TABLE extends TABLEElement {\n    !unique !ordered attr EString border;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString cellspacing;\n    !unique !ordered attr EString cellpadding;\n    !ordered val TR[*]#table trs;\n  }\n\n  class TR extends TABLEElement {\n    !unique !ordered attr EString valign;\n    !unique !ordered attr EString align;\n    !ordered ref TABLE#trs table;\n    !ordered val TD[*]#tr tds;\n  }\n\n  class TD extends TABLEElement {\n    !unique !ordered attr EString colspan;\n    !unique !ordered attr EString rowspan;\n    !unique !ordered attr EString valign;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString width;\n    !ordered ref TR#tds tr;\n  }\n\n  class TH extends TD {\n  }\n\n  class FORM {\n    !unique !ordered attr EString action;\n    !unique !ordered attr EString method;\n  }\n\n  class INPUT {\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString maxlength;\n    !unique !ordered attr EString size;\n    !unique !ordered attr EString checked;\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString inputValue;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString type;\n  }\n\n  class TEXTAREA {\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString rows;\n    !unique !ordered attr EString cols;\n  }\n\n  class SELECT {\n    !unique !ordered attr EString multiple;\n    !unique !ordered attr EString size;\n    !unique !ordered attr EString name;\n  }\n\n  class OPTION {\n    !unique !ordered attr EString selected;\n    !unique !ordered attr EString optionValue;\n  }\n\n  abstract class ListElement {\n    !unique !ordered attr EString type;\n  }\n\n  class OL extends ListElement {\n    !unique !ordered attr EString start;\n  }\n\n  class UL extends ListElement {\n  }\n\n  class LI extends ListElement {\n    !unique !ordered attr EString liValue;\n  }\n\n  class DL {\n  }\n\n  class DT {\n  }\n\n  class DD {\n  }\n\n  class APPLET {\n    !unique !ordered attr EString applet;\n    !unique !ordered attr EString ~class;\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n  }\n\n  class PARAM {\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString paramValue;\n  }\n\n  class OBJECT {\n    !unique !ordered attr EString classid;\n    !unique !ordered attr EString ~id;\n    !unique !ordered attr EString data;\n    !unique !ordered attr EString type;\n    !unique !ordered attr EString standby;\n  }\n\n  class FRAMESET {\n    !unique !ordered attr EString rows;\n    !unique !ordered attr EString cols;\n    !unique !ordered attr EString framespacing;\n    !unique !ordered attr EString frameborder;\n    !unique !ordered attr EString border;\n  }\n\n  class FRAME {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString marginwidth;\n    !unique !ordered attr EString marginheight;\n    !unique !ordered attr EString scrolling;\n    !unique !ordered attr EString noresize;\n  }\n\n  class NOFRAME {\n  }\n\n  class IFRAME extends FRAME {\n  }\n\n// Based on https://github.com/SATToSE/SoTeSoLa2012/blob/master/hackathon/modisco-eclipse/org.eclipse.gmt.modisco.tool.metricsvisualizationbuilder/Metamodels/HTML.ecore\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#source-model","title":"Source Model","text":""},{"location":"examples/flowchart-to-html-example.html#wakeup-flowchart","title":"Wakeup Flowchart","text":"<p>Let's turn that flowchart into an XMI representation because that is the required format for source models in YAMTL (note that this is equivalent to the Flexmi code shown on the previous page):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#wakeup-flowchart-with-subflow","title":"Wakeup Flowchart with Subflow","text":"<p>Some MTL examples also transform the Flowchart's subflow elements, so, another flowchart (that contains subflow) based on the original flowchart is also defined. The flowchart model with subflow is as follows:</p> <p>Graphical Representation</p> <p></p> <p>Abstract Syntax in XMI</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Subflow\" xmi:id=\"_BYIhADZzEeOvH6AlutIRRw\" name=\"Snoozing\"&gt;\n    &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;/nodes&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#target-model","title":"Target Model","text":"<p>Since the problem is open-ended there is no one solution i.e. no final target model to achieve. Check out the MTL Solutions below to see the advanced functionalities (special operations and concepts) of each MTL.</p>"},{"location":"examples/flowchart-to-html-example.html#flowchart-to-html-yamtl-implementation","title":"Flowchart to HTML - YAMTL Implementation","text":"<p>In this tutorial, the core concepts of YAMTL transformations will be described. To do this, elements of a flowchart model will be transformed using special operations into valid HTML elements.</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>The flowchart model (abstract representation shown in the figure above) has different types of elements: Node, Action, Decision, Transition, and Subflow.</p> <p>Node elements are the most basic elements in a flowchart. They can have any number of incoming and outgoing transitions.</p> <p>Action elements are a type of Node element. They have a value describing an action and such elements can also have any number of incoming and outgoing transitions.</p> <p>Decision elements are another type of Node element. Its value indicates a decision (if-else condition) and a decision element can have any number of incoming and outgoing transitions.</p> <p>Transition elements are those arrows (direction flow) in the flowchart figure above. They have a name attribute. A transition element must have one source Node (start of the arrow) and one target Node (end of the arrow).</p> <p>Subflow is a special Node element that contains a flowchart inside a flowchart (making it a sub-section). A subflow element has a name and all the features of a flowchart i.e. can have any number of nodes and transitions.</p>"},{"location":"examples/flowchart-to-html-example.html#basic-example","title":"Basic Example","text":"<p>This is a simple example that converts all flowchart elements into HTML <code>H1</code> headings:</p> <pre><code>ruleStore([\n    rule('Flowchart2Heading')\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = f.name\n        }),\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = a.name\n        }),\n    rule('Decision2Heading')\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = d.name\n        }),\n    rule('Transition2Heading')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = t.name\n        })\n])\n</code></pre> <p>In this code snippet, 4 rules transform different flowchart objects: Flowchart, Action, Decision, and Transition; into H1 elements. Each rule has a name (within <code>rule('&lt;ruleName&gt;')</code> clause), an input element (with a name and type), and an output element (with a name, type and a lamda expression). The lambda expression of all rules follow the same format: assign the name of the input object to the value of the heading <code>H1</code>.</p>"},{"location":"examples/flowchart-to-html-example.html#rule-inheritance","title":"Rule Inheritance","text":"<p>First, an abstract rule is defined with a set of input and output elements. Then, a child rule is declared which inherits from the abstract rule (parent) and performs the transformation. YAMTL also supports multiple rule inheritance where a child rule can inherit from multiple parent rules.</p> <pre><code>ruleStore([\n    // This parent rule is abstract, so it will not be applied directly\n    // but it can be executed by its children\n    rule('Flowchart2H1')\n            .isAbstract()\n            .in(\"e\", flowchartPk.Flowchart)\n            .out(\"h1\", htmlPk.H1, {\n                h1.value = \"Flowchart \" + e.name\n            }),\n\n    // This child rule inherits from the previous one\n    rule('Subflow2H1')\n            .inheritsFrom(['Flowchart2H1'])\n            .in(\"e\", flowchartPk.Subflow)\n            .out(\"h1\", htmlPk.H1, {\n                // R.H.S. h1.value is inherited from the parent rule\n                // 'e' object is passed to the parent rule to calculate h1.value\n                h1.value = \"Subflow \" + h1.value\n            })\n])\n</code></pre> <p><code>isAbstract()</code> clause is used to define an abstract rule. The abstract rule contains an input element of type <code>Flowchart</code> and an output element of H1 heading. The output object's value is updated to the input object's name with a prefix \"Flowchart\". A new child rule that inherits from the abstract rule using the <code>inheritsFrom(['&lt;ruleNameList&gt;'])</code> clause. The child rule <code>Subflow2H1</code> has an input element of type <code>Subflow</code> which extends <code>Flowchart</code>. Its name is <code>e</code> just like in the parent rule, meaning when the child rule is executed the input object <code>e</code>  overrides the object <code>e</code> in the parent rule. The output element's type must be the same as the parent rule. The output object's value is \"Subflow \" followed by the value of <code>h1</code> in the abstract rule because both rules are executed and the output objects are calculated. Thus, the final output is an H1 element of the following format:</p> <pre><code>&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#rule-override","title":"Rule Override","text":"<p>There may be cases where you need to override the output object of the parent rule. This means that when the rule that inherits is executed, the value of the output object in the parent rule is overridden by the value of the output object calculated in the child rule. This also means that the child output object has no value at the start of execution unlike when it is inherited with no override.</p> <pre><code>ruleStore([\n    rule('Flowchart2H1')\n        .in(\"e\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            //Assigns the name of the flowchart to the value of the h1 element\n            h1.value = \"Flowchart \" + e.name \n        }),\n\n    rule('Subflow2H1')\n        .inheritsFrom(['Flowchart2H1'])\n        .in(\"e\", flowchartPk.Subflow)\n        .out(\"h1\", htmlPk.H1, {\n\n            //If h1 value is inherited then it is not null, else it is null\n            if(h1.value !== null) {\n                //R.H.S h1.value is already calculated and inherited\n                h1.value = \"Subflow \" + h1.value\n            } else {\n                //h1 is newly initialised since rule is overridden\n                h1.value = \"Subflow \" + e.name //Overridden output object\n            }\n        //Override the parent rule so the child rule's h1 object is used    \n        }).overriding()\n        //Try out the above transformation without the overriding() method\n        //and see the difference in inheritance behaviour   \n])\n</code></pre> <p>To better understand the properties of the <code>overriding()</code> clause, you should see the difference in execution and output, when you use override and when you do not.</p> <p>When you use <code>overrding()</code>:</p> <p>The rule that inherits (<code>Subflow2H1</code>), overrides the parent rule's (<code>Flowchart2H1</code>) output object <code>h1</code> meaning its value is newly initialized (<code>null</code>), thus, the else-condition is invoked. The local input object <code>e</code> is referenced within the output block and its name (<code>e.name</code>) is retrieved to be assigned as part of a string to the value of <code>h1</code>. The output of this transformation would look like this:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Snoozing\"/&gt;\n</code></pre> <p>When you do not use <code>overriding()</code>:</p> <p>When the child rule is executed, the output element(s) of the parent rule is calculated first. This means that <code>h1</code> output object has a computed value in the parent rule. When you access the <code>h1</code> output object in the child rule, it references to the parent rule's <code>h1</code> output object (which contains a value). Thus, the if-condition is satisfied and the child rule's output object <code>h1</code> is assigned the value of a string and the value of <code>h1</code> object calculated within the parent rule. The main output of this transformation would be:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#lazy-rules","title":"Lazy Rules","text":"<p>A lazy rule is a rule that is executed after all non-lazy rules. When multiple lazy rules are defined, then the lazy rules are invoked in sequential order.</p> <pre><code>ruleStore([\n    rule('Flowchart2Heading')\n        .in('f', flowchartPk.Flowchart)\n        .out('div', htmlPk.DIV, {\n            // without LAZY: div.children.addAll(fetch(f.nodes))\n            // with LAZY rules\n            div.children.addAll(fetch(f.nodes, 'out', 'NodeRule'))\n        }),\n    rule('NodeRule')\n        .isUniqueLazy()\n        .in(\"in\", flowchartPk.Node)\n        .out(\"out\", htmlPk.H1, {\n            out.value = in.name\n        }),\n    rule('Transition2H1')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", flowchartPk.H1, {\n            h1.value = t.name\n        })\n])\n</code></pre> <p>A <code>lazy</code> rule is called and not scheduled by the YAMTL engine, which may lead to different results each time the rule is executed. A <code>uniqueLazy</code> rule always outputs the same result no matter how many times it is invoked and executed. In the code snippet above, <code>Flowchart2Heading</code> rule adds some nodes to a <code>div</code> HTML block. The <code>div</code> adds children from another rule using a special <code>fetch</code> operation: <code>fetch(inputMatchedObject, outVarName, ruleName)</code>, where <code>inputMatchedObject</code> can be just a single value or a collection; <code>outVarName</code> is the name of the output object of the other rule which is being accessed; <code>ruleName</code> is the name of that other rule. In this example, <code>inputMatchedObject</code> is <code>f.nodes</code> which is a collection of <code>Node</code> objects found in the output object of the matched <code>NodeRule</code>. Since <code>NodeRule</code> has not been executed, the values of <code>div</code> are not populated just yet. Next, <code>NodeRule</code> is tagged as <code>uniqueLazy</code> so it is not executed and is skipped for now. <code>Transition2H1</code> rule transforms all <code>Transition</code> elements into <code>H1</code> headings, where the value of an <code>H1</code> element is the the name of the <code>Transition</code> passed to the input pattern. Now all non-lazy rules have been invoked so the <code>uniqueLazy</code> rule (<code>NodeRule</code>) can be executed next. All <code>Node</code> objects are transformed into <code>H1</code> HTML elements, where each <code>H1</code> output object's value is the name of the <code>Node</code> object it has been transformed from. This rule generates a collection of <code>H1</code> headings which can finally be passed to the special <code>fetch</code> operation of <code>Flowchart2Heading</code> rule. Thus, the <code>div</code> output object contains a collection of <code>H1</code> elements with names of <code>Node</code> objects as their values.</p>"},{"location":"examples/flowchart-to-html-example.html#transient-rules","title":"Transient Rules","text":"<p>Transient rules are rules whose output is not persisted in the target model. They are used to perform calculations and update objects in the target model. The transient clause is used to define a transient rule.</p> <pre><code>// an attribute shared among rules\ndef count = 0\n\nruleStore([\n    rule('Transitions2Div')\n        .isTransient()\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"div\", htmlPk.DIV, {\n            count++\n            println(count)\n        }),         \n    rule('FlowChart')\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = \"The ${f.name} flowchart has ${count} transitions\"\n                        .toString()\n        })\n])\n])\n</code></pre> <p>In the above example, the <code>Transitions2Div</code> rule is declared as transient. The <code>out</code> block is used to update the <code>count</code> variable with the number of children in the <code>div</code> output object, which happens automatically due to the number of transition elements (inputs) that match the rule. The <code>FlowChart</code> rule is not transient and it has an input object of type <code>Flowchart</code> and an output object of type <code>H1</code>. The value of the <code>H1</code> output object is a string that contains the name of the flowchart and the value of the <code>count</code> variable.</p>"},{"location":"examples/flowchart-to-html-example.html#rule-filtering","title":"Rule Filtering","text":"<p>In this example, a filter condition (which is a lambda expression) is applied to a rule to transform selected input objects.</p> <pre><code>ruleStore([\n    rule('SelectedTransitions2Text')\n        .in(\"t\", flowchartPk.Transition)\n        .filter{    \n            //Filter input objects that satify this condition\n            t.source.name == \"Is it really too early?\"      \n        }\n        .out(\"p\", htmlPk.P, {\n            p.value = t.name\n        })\n])\n</code></pre> <p>The rule <code>SelectedTransitions2Text</code> has an input element as a <code>Transition</code> object. A filter condition is applied to check the name of the transition's source. If the transition source name is \"Is it really too early?\" then only those input <code>Transition</code> objects will be transformed. The output element is an HTML paragraph element <code>p</code> whose value is updated to the name of the input <code>Transition</code> object.</p>"},{"location":"examples/flowchart-to-html-example.html#derived-input-elements","title":"Derived Input Elements","text":"<p>Derived elements are derived from input elements that have been matched in preceding input patterns of a rule. Here, the matching process is manually described instead of the automatic matching in matched elements.</p> <pre><code>ruleStore([\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .in(\"b\", flowchartPk.Action).derivedWith{ \n            def f = a.eContainer()\n            f.nodes.first()\n        }\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = b.name\n        })\n])\n</code></pre> <p>The rule <code>Action2Heading</code> contains an input object <code>b</code> that is derived from input object <code>a</code>'s first <code>Action</code> node. The output object <code>H1</code> is an HTML heading element with the value as the name of <code>b</code> input object. Note, that in the 'wakeup' flowchart model there are 4 <code>Action</code> elements so each of those is passed through the input patterns but since the <code>b</code> input object is derived from the first <code>Node</code> object of the <code>f</code> flowchart (<code>a</code>'s eContainer is the Flowchart object), the output will always be the name of the first node ('Wake up'). The result in the target model would look like this:</p> <pre><code>&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#multiple-sources","title":"Multiple Sources","text":"<p>If you want to transform multiple input objects into a single output object, you can do so by using the <code>in</code> clause multiple times. The input objects are matched in the order they are declared in the rule. Remember, the total number of input objects created is the cartesian product of the input objects of each input pattern. Usually, a filter is applied to the rule to ensure that the input objects are matched correctly and specifically chosen input objects are transformed.</p> <pre><code>ruleStore([\n    rule('SelectedTransitions2Text')\n        // This rule contains 3 input patterns\n        // Multiple sources create a cartesian product of output elements\n        // So filters are needed to avoid creating unwanted elements\n        .in(\"a\", flowchartPk.Action)\n        .filter {\n            // Filter out those actions that do not have outgoing transitions\n            !a.outgoing.isEmpty()\n        }\n        .in(\"d\", flowchartPk.Decision)\n        .in(\"t\", flowchartPk.Transition)\n        .filter{                        \n                // Only transform actions that match the input transition name\n                // OR\n                // decision elements that contain the input transition name\n                a.outgoing.name[0] == t.name || d.outgoing.name.contains(t.name)\n            }\n        .out(\"p\", htmlPk.P, {\n\n        // Create &lt;p&gt; elements with source, transition, and target info for action and decision elements\n        // Multiple duplicates of the decision element will be created showcasing the cartesian product behaviour\n            if(a.outgoing.name[0] == t.name) {\n                p.value = \"Source: ${a.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            } else if(d.outgoing.name[0] == t.name) {\n                p.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            } else if(d.outgoing.name[1] == t.name) {\n                p.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            }\n        })\n])\n</code></pre> <p>In the above example, the rule <code>SelectedTransitions2Text</code> has 3 input objects: <code>a</code> of type <code>Action</code>, <code>d</code> of type <code>Decision</code> and <code>t</code> of type <code>Transition</code>. A filter is applied to the rule to ensure that the input objects are matched correctly. The filter condition checks if the <code>Action</code> object has an outgoing transition and if the name of the first outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Action</code> object, the name of the <code>Transition</code> object and the name of the target of the <code>Transition</code> object. If the second condition (regarding equivalent names) is not satisfied, then the filter condition checks if the <code>Decision</code> object has an outgoing transition and if the name of the outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object. If the condition is not satisfied, then the filter condition checks if the <code>Decision</code> object has a second outgoing transition and if the name of the second outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object.</p>"},{"location":"examples/flowchart-to-html-example.html#mulitple-targets","title":"Mulitple Targets","text":"<p>If you want to transform a single input object into multiple output objects, you can do so by using the <code>out</code> clause multiple times. The output objects are created in the order they are declared in the rule.</p> <pre><code>ruleStore([\n    rule('Action2Elements')\n        // This rule has 1 input pattern and 3 output patterns\n        // All output objects are mapped to the same input object\n        .in(\"a\", flowchartPk.Action).filter { !a.outgoing.isEmpty() }\n        .out(\"title\", htmlPk.H1, {\n            title.value = a.name\n        })\n        .out(\"link\", htmlPk.A, {\n            link.value = \"Next steps\"\n            link.ahref = a.outgoing.first().target.name\n        })\n        .out(\"container\", htmlPk.DIV, {\n            // output vars of the rule can be referred directly\n            container.children.add(title)\n            container.children.add(link)\n        })\n])\n</code></pre> <p>In this scenario, there are 3 output objects: <code>title</code>, <code>link</code>, and <code>container</code>. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>a</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code> whose value is \"Next steps\" and the reference link is the name of the first outgoing transition's target. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The output of this transformation would look like this. The overall transformation converts <code>Action</code> elements into a <code>DIV</code> element that contains a <code>H1</code> element and an <code>A</code> element.</p>"},{"location":"examples/flowchart-to-html-example.html#to-many-operation","title":"To Many Operation","text":"<p>Matched rules can be declared with the modifier <code>toMany</code> that enables repeated rule application for the same input object subject to a valid termination condition <code>toManyCap</code> based on the match count. The argument passed to <code>toManyCap</code> is the number of output patterns in that rule. With <code>toMany</code> rules, the same rule may match the same object several times. In this case, we can refer to each (occurrence of a) match by the order in which they occurred: <code>fetch(inputMatchedObject, i)</code> will return the output object that was created by the <code>i</code>th match.</p> <p>When the output pattern consists of several object patterns, we need to specify the output object that we want to fetch: <code>fetch(inputMatchedObject, outVarName)</code> will return the output object corresponding to the output variable <code>outVarName</code>. If a matched rule with a complex output pattern is also declared as <code>toMany</code>, then we can retrieve the output object with the expression <code>fetch(inputMatchedObject, outVarName, i)</code>.</p> <pre><code>ruleStore([\n    rule('Action2Elements')\n        .toMany()\n        .toManyCap({2})\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"title\", htmlPk.H1, {\n            // The value will differ every time the rule is re-applied\n            title.value = d.name \n        })\n        .out(\"link\", htmlPk.A, {\n            // Access the current number of rule application\n            // using matchCount variable\n            if (matchCount == 0) {\n                link.name = \"Transition link 1\"\n                link.value = fetch(d, \"title\", 0).value\n                link.ahref = d.outgoing[0].name\n            } else {\n                link.name = \"Transition link 2\"\n                link.value = fetch(d, \"title\", 1).value\n                link.ahref =  d.outgoing[1].name\n            }\n        })\n        .out(\"container\", htmlPk.DIV, { \n            // Fetch the correct title and link for the current rule matching\n            container.value = \"Decision ${matchCount+1}\".toString()\n            container.children.add(fetch(d, \"title\", matchCount))\n            container.children.add(fetch(d, \"link\", matchCount))\n        })\n\n])\n</code></pre> <p>The above excerpt contains just one rule <code>Action2Elements</code> with one input pattern and multiple output patterns. <code>toManyCap({2})</code> means that the same rule is applied twice. This is useful to execute when the rule is needed to be executed multiple times to get different output or to get the same output multiple times. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>d</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code>. <code>matchCount</code> variable store the value of the current cycle of rule application, it is always between 0 and n (<code>toManyCap{n}</code>). In the first cycle of rule application, the <code>link</code> name, value (fetched from <code>title</code> object of the same cycle <code>0</code>) and the reference link (name of the first outgoing transition's name) is set. In the second cycle, we implement similar but different attributes to showcase the use of <code>matchCount</code>. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The corresponding value of the <code>i</code>th iteration of the rule application must be applied (in the third argument of <code>fetch()</code>), which is best set as <code>matchCount</code> variable. This means that in each cycle of rule execution, the title and link elements generated in that cycle are added to the container.</p>"},{"location":"examples/flowchart-to-html-example.html#end-with-block","title":"End With Block","text":"<p>If you want elements of a rule to interact with each other, you can do so at the end of a rule execution using an optional operation called <code>endWith</code>. An <code>endWith</code> block allows the user to group all elements of a rule, update objects and perform calculations using lamda expressions.</p> <pre><code>ruleStore([\n    rule('Flowchart2Body')\n        //Notice there is one source and multiple targets\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"b\", htmlPk.B, { \n            //Flowchart's name is turned into bold\n            b.value = f.name \n        })\n        .out(\"div\", htmlPk.DIV, {\n            //A div block contains all model transitions \n            div.children.addAll(f.transitions) \n        })\n        .out(\"body\", htmlPk.BODY, {\n            //All flowchart nodes are added to the body\n            body.children.addAll(f.nodes)\n        })//Last block of the transformation to be executed\n        .endWith({\n            //You can access the input object(s)\n            body.text = f.name\n\n            //Similarly, you can access all output object(s)\n            body.children.add(b) \n            body.children.add(div)\n    })\n])\n</code></pre> <p>In the transformation example above, one source element <code>f</code> is transformed into multiple targets: <code>b</code> is a <code>Bold</code> HTML element that is assigned the flowchart's name as its value, <code>div</code> output object has all transitions of the flowchart <code>f</code> as its children, and <code>body</code> output object has all flowchart <code>f</code> nodes as its children. Once, all output blocks are executed, the <code>endWith</code> block is invoked. In the <code>endWith</code> block, a lambda expression is defined that updates the <code>body</code> output object's text field with the <code>f</code> flowchart's name and the <code>body</code> object also adds new children: <code>b</code> output object and <code>div</code> output object. These updates are shown in the output, found in the target model.</p>"},{"location":"examples/flowchart-to-html-example.html#rule-priority","title":"Rule Priority","text":"<p>As the title suggests, you can prioritize rules to be executed in the order you prefer using the <code>priority(P)</code> clause where <code>P</code> is a whole number (e.g. 0, 1, 2,...) and the rules are executed in ascending values of <code>P</code> i.e. rules with lower <code>P</code> values have higher priority. </p> <pre><code>ruleStore([\n    //Run this rule first\n    rule('Flowchart2Title')\n        .priority(1)\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"title\", htmlPk.TITLE, {\n            title.value = f.name \n        }),\n    //Run this third\n    rule('Action2Heading')\n        .priority(3)\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h2\", htmlPk.H2, {\n            h2.value = \"H2 heading for Action: \" + a.name\n        }),\n    //Run this rule second          \n    rule('Decision2Heading')\n        .priority(2)\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = \"H1 heading for Decision: \" + d.name \n        }),\n    //Finally run this rule\n    rule('Transition2Heading')\n        .priority(4)\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h3\", htmlPk.H3, {\n            h3.value = \"H3 heading for Transition: \" + t.name\n        })  \n])\n</code></pre> <p>In the MT definition above, the flow of execution for all the rules is:</p> <ol> <li><code>Flowchart2Title</code></li> <li><code>Decision2Heading</code></li> <li><code>Action2Heading</code></li> <li><code>Transition2Heading</code></li> </ol> <p>So you can expect the output of this transformation to also be ordered in the above manner within the target model.</p>"},{"location":"examples/flowchart-to-html-example.html#helpers","title":"Helpers","text":"<p>Helpers offer reusable expressions for rules. They can be used to define static attributes and operations, and contextual operations.</p> <ul> <li>A static attribute is a constant value that can be used in a rule. It is defined using the <code>staticAttribute('&lt;attributeName&gt;', { &lt;attributeValue&gt; })</code> clause. The attribute value can be a primitive value or an <code>EObject</code>. The attribute can be accessed in a rule using the <code>&lt;attributeName&gt;</code> variable. The power of this helper can be displayed using an allInstances(<code>EClass</code>) operation within the helper definition.</li> <li>A static operation is a static method which is defined for the class. It is defined using the <code>staticOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The operation body is a lambda expression that has a list of parameters specified as an arguments map (<code>argMap</code>) which must return a value.  The operation can be accessed in a rule using the <code>&lt;operationName&gt;</code> variable.</li> <li>A contextual operation is a bi-function that allows you to manipulate an argument object (could be an input or output object) and an argument map (which can be passed in between a rule and a helper). This a method invoked on a contextual instance of an object (first argument of the operation). It is defined using the <code>contextualOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The contextual operation body is a lambda expression that can contain two main arguments. The operation can be accessed in a rule using the <code>c_op</code> variable. The contextual operation is used to access the contextual instance of the input object and it must return either an <code>EObject</code> or a primitive value. The contextual instance is the input object that is matched in the input pattern of the rule. The contextual instance can be accessed in the operation body using the <code>obj</code> variable.</li> </ul> <pre><code>ruleStore([\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = att.toString()\n        }),\n    rule('Decision2Heading')\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            //Call 'op' helper and pass the decision object as a key map\n            h1.value = op(['obj': d])\n        }),\n    rule('Transition2Heading')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", htmlPk.H1, {\n            //Call 'c_op' helper and pass the transition object as a key map\n            //Also pass a suffix increment argument to the contextual operation\n            h1.value = c_op(t, ['suffix': \"_${i++}\"])\n        })\n])\n\nhelperStore([\n    staticAttribute('att', { \n        def actionList = []\n        for (anAction in allInstances(flowchartPk.Action)) {\n            actionList.add(anAction.name)\n        }\n\n        //returns all instances of Action elements from the source model\n        return actionList\n    }),\n    staticOperation('op', { argsMap -&gt;\n        //returns the argument 'obj'\n        return argsMap.obj.name\n    }),\n    contextualOperation('c_op', { obj, argsMap -&gt;\n        //returns the name of the contextual instance 'obj' and argument 'suffix'\n        return obj.name + argsMap['suffix']\n    })\n])\n</code></pre> <p>In the example above, all flowchart elements are transformed into <code>H1</code> HTML headings. Within the <code>staticAttribute()</code> helper function, the <code>att</code> attribute returns a list of all instances of <code>Action</code> element in the source model. which is used in the <code>Action2Heading</code> rule. The <code>op</code> static operation returns the name of the <code>Decision</code> object <code>d</code> (passed as the value of a key map) which is used in the <code>Decision2Heading</code> rule. The <code>c_op</code> contextual operation returns the name of the <code>Transition</code> object appended by the value of the <code>suffix</code> argument (<code>i</code> increment counter) which is used in the <code>Transition2Heading</code> rule. This MT definition showcases all types of helpers and how they can be used in rules.</p>"},{"location":"examples/flowchart-to-html-example.html#model-queries","title":"Model Queries","text":"<p>A model query is a rule that has an input pattern and no output pattern. It may have an <code>endWith</code> block to report error messages or compute metrics. The <code>query()</code> clause is used to define a model query. The transformation definition for a model query would look like this:</p> <pre><code>ruleStore([\n    rule('Transition')\n        .in('t', flowchartPk.Transition)\n        .query()\n        .endWith{\n            println(\"processed successfully\")\n        }                \n    ])\n</code></pre> <p>Model queries require additional configuration when you execute the YAMTL module:</p> <pre><code>def mm = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore')\ndef query = new Query(mm.contents[0])\nYAMTLGroovyExtensions.init(this)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nquery.execute()\n</code></pre> <p>The <code>selectedExecutionPhases</code> variable is set to <code>MATCH_ONLY</code> to only execute the input pattern of the model query. The <code>loadInputModels()</code> function is used to load the input model. The <code>execute()</code> function is used to execute the model query. The <code>endWith</code> block is executed after the input pattern is matched which outputs a message to the console.</p>"},{"location":"examples/flowchart-to-html-example.html#module-composition","title":"Module Composition","text":"<p>You also have the capability to extend a YAMTL module by inheriting from it. This is called module composition. The <code>extends</code> clause is used to inherit from a YAMTL module. The transformation definition for module composition would look like this:</p> <pre><code>class ModuleComposition extends Inheritance {\n    public ModuleComposition(EPackage flowchartPk, EPackage htmlPk) {\n        super(flowchartPk, htmlPk)\n\n        ruleStore([\n            rule('Subflow2H1')\n                .inheritsFrom(['Flowchart2H1'])\n                .in(\"e\", flowchartPk.Subflow)\n                .out(\"h1\", htmlPk.H1, {\n                    h1.value = \"${h1.value}, where name of subflow is ${e.name}\"\n                                .toString()                         \n                })\n        ])\n}}\n</code></pre> <p><code>ModuleComposition</code> module extends the <code>Inheritance</code> module, which allows a rule to inherit from other rule(s) from a different module. The <code>inheritsFrom()</code> clause is used to inherit from a rule. The <code>Subflow2H1</code> rule inherits from the <code>Flowchart2H1</code> rule. The <code>h1</code> output object is updated to a string that contains the value of the <code>h1</code> output object from the <code>Flowchart2H1</code> rule and the name of the <code>Subflow</code> object <code>e</code>. The <code>ModuleComposition</code> module can be executed in the same way as the <code>Inheritance</code> module.</p>"},{"location":"examples/flowchart-to-html-example.html#transformation-test-script","title":"Transformation Test Script","text":"<p>The test script is responsible for loading source and target metamodels, initializing the MT definition, loading soure model into the transformation and executing it, and saving the output in the target model.</p> <pre><code>// model transformation execution\ndef srcRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore') \ndef tgtRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/html.ecore')\n\ndef xform = new &lt;groovyClass&gt;(srcRes.contents[0], tgtRes.contents[0])\nYAMTLGroovyExtensions.init(this)\nxform.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nxform.execute()\nxform.saveOutputModels(['out': BASE_PATH + '/&lt;outputFileName&gt;.xmi'])\n\n// test assertion\ndef actualModel = xform.getOutputModel('out')\nEMFComparator comparator = new EMFComparator();\n// Load the expected model using the identical output metamodel from the transformation.\n// Essentially, use the same in-memory metamodel.\nxform.loadMetamodelResource(tgtRes) \ndef expectedResource = xform.loadModel(BASE_PATH + '/&lt;expectedOutputFileName&gt;.xmi', false)\ndef assertionResult =  comparator.equals(expectedResource.getContents(), actualModel.getContents()) \nassertTrue(assertionResult);\n</code></pre> <p>First, both source and target metamodels are each loaded as a resource using a <code>YAMTLModule</code> function called <code>loadMetamodel(&lt;'projectPath'&gt;)</code>. <code>.ecore</code> files and their components are accessed using the <code>resourceName.contents[0]</code> clause. Note that <code>BASE_PATH</code> is just a global variable (with the value 'model' in this case) containing base directory name. <code>xform</code> variable initializes a new MT definition if a valid Groovy class name and parameters (source and target metamodels) are provided. Next, the input model is loaded using project path and the transformation is executed. The output is saved within the target model in the location (path) provided.</p> <p>The test assertion is performed using the <code>EMFComparator</code> package which compares the expected and actual output models. The expected model is loaded from the 'model' directory. The <code>assertionResult</code> variable is a boolean that is true if the expected and actual models are equal. The assertion is performed using the <code>assertTrue()</code> function. In case, the assertion fails, it means the project is not configured correctly or the transformation definition was changed to give a different output.</p>"},{"location":"examples/flowchart-to-html-example.html#development-platforms","title":"Development Platforms","text":"<p>Go to the YAMTL examples GitHub repository and clone it. The root directory is the base of all YAMTL example projects, and you will need to import this directory to configure and build the Gradle project.  You can import the project into an IDE of your choice. The following steps will provide details on how to set up the example project on Eclipse, IntelliJ, and VSCode.</p> <p>YAMTL uses Groovy scripts to define the models and transformations so generally any IDE will need some Groovy support through extensions/plug-ins. Make sure to have YAMTL correctly configured or do the necessary steps found in the YAMTL Workspace Configuration section before you run the project.</p>"},{"location":"examples/flowchart-to-html-example.html#eclipse","title":"Eclipse","text":"<p>In Eclipse, click on <code>File \u2192 Import \u2192 Existing Gradle Projects into Workspace \u2192 Select root directory of the Git repo \u2192 Finish</code>. This will import and load the project in the IDE.</p> <p>Head over to the <code>FlowchartToHTML</code> module within Eclipse, right-click on a test script of your choice in the <code>src/test/groovy</code> folder then <code>Run as \u2192 JUnit Test</code>. Once the test is completed, a new output file (XMI format) will be generated in the <code>model</code> directory. Examine this file.</p>"},{"location":"examples/flowchart-to-html-example.html#intellij","title":"IntelliJ","text":"<p>Within IntelliJ, go to <code>File \u2192 Open</code> and open the project at the root directory of the Git repository.</p> <p>Right-click on <code>src/test/groovy/flowchartToHtmlExamples</code> folder (within the <code>FlowchartToHTML</code> project directory), then 'Run Tests...'. </p> <p>Alternatively, click on the green run button in the top bar which builds the project and generates output files of all transformations in the <code>model</code> directory. </p>"},{"location":"examples/flowchart-to-html-example.html#vscode","title":"VSCode","text":"<p>In VSCode, import the project at the root directory of the Git repository by doing <code>File \u2192 Open</code>.</p> <p>After you have imported the <code>FlowchartToHTML</code> project into the workspace, click on the Gradle icon in the left sidebar. Choose, the <code>FlowhchartToHTML</code> project and then perform <code>Tasks \u2192  build \u2192 clean</code>. Do <code>Tasks \u2192 build \u2192 build</code> to build the entire Gradle project (it also runs all test scripts that execute the transformations). </p> <p>Once the project is successfully built, all output files will be generated in the <code>model</code> directory. Examine these files.</p>"},{"location":"examples/flowchart-to-html-example.html#references","title":"References","text":"<ul> <li>YAMTL Syntax</li> <li>YAMTL Incremental Support</li> <li>YAMTL Original Documentation</li> </ul>"},{"location":"examples/flowchart-to-html-yamtl.html","title":"Flowchart to HTML - YAMTL Implementation","text":"<p>In this tutorial, the core concepts of YAMTL transformations will be described. To do this, elements of a flowchart model will be transformed using special operations into valid HTML elements.</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>The flowchart model (abstract representation shown in the figure above) has different types of elements: Node, Action, Decision, Transition, and Subflow.</p> <p>Node elements are the most basic elements in a flowchart. They can have any number of incoming and outgoing transitions.</p> <p>Action elements are a type of Node element. They have a value describing an action and such elements can also have any number of incoming and outgoing transitions.</p> <p>Decision elements are another type of Node element. Its value indicates a decision (if-else condition) and a decision element can have any number of incoming and outgoing transitions.</p> <p>Transition elements are those arrows (direction flow) in the flowchart figure above. They have a name attribute. A transition element must have one source Node (start of the arrow) and one target Node (end of the arrow).</p> <p>Subflow is a special Node element that contains a flowchart inside a flowchart (making it a sub-section). A subflow element has a name and all the features of a flowchart i.e. can have any number of nodes and transitions.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#source-metamodel","title":"Source Metamodel","text":"<p>This is the flowchart metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#target-metamodel","title":"Target Metamodel","text":"<p>This is the HTML metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#source-model","title":"Source Model","text":""},{"location":"examples/flowchart-to-html-yamtl.html#wakeup-flowchart","title":"Wakeup Flowchart","text":"<p>Let's turn that flowchart into an XMI representation because that is the required format for source models in YAMTL (note that this is equivalent to the Flexmi code shown on the previous page):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-yamtl.html#wakeup-flowchart-with-subflow","title":"Wakeup Flowchart with Subflow","text":"<p>Some MTL examples also transform the Flowchart's subflow elements, so, another flowchart (that contains subflow) based on the original flowchart is also defined. The flowchart model with subflow is as follows:</p> <p>Graphical Representation</p> <p></p> <p>Abstract Syntax in XMI</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Subflow\" xmi:id=\"_BYIhADZzEeOvH6AlutIRRw\" name=\"Snoozing\"&gt;\n    &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;/nodes&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-yamtl.html#transformation-examples","title":"Transformation Examples","text":""},{"location":"examples/flowchart-to-html-yamtl.html#basic-example","title":"Basic Example","text":"<p>This is a simple example that converts all flowchart elements into HTML <code>H1</code> headings:</p> <pre><code>ruleStore([\n    rule('Flowchart2Heading')\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = f.name\n        }),\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = a.name\n        }),\n    rule('Decision2Heading')\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = d.name\n        }),\n    rule('Transition2Heading')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = t.name\n        })\n])\n</code></pre> <p>In this code snippet, 4 rules transform different flowchart objects: Flowchart, Action, Decision, and Transition; into H1 elements. Each rule has a name (within <code>rule('&lt;ruleName&gt;')</code> clause), an input element (with a name and type), and an output element (with a name, type and a lamda expression). The lambda expression of all rules follow the same format: assign the name of the input object to the value of the heading <code>H1</code>.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#rule-inheritance","title":"Rule Inheritance","text":"<p>First, an abstract rule is defined with a set of input and output elements. Then, a child rule is declared which inherits from the abstract rule (parent) and performs the transformation. YAMTL also supports multiple rule inheritance where a child rule can inherit from multiple parent rules.</p> <pre><code>ruleStore([\n    // This parent rule is abstract, so it will not be applied directly\n    // but it can be executed by its children\n    rule('Flowchart2H1')\n            .isAbstract()\n            .in(\"e\", flowchartPk.Flowchart)\n            .out(\"h1\", htmlPk.H1, {\n                h1.value = \"Flowchart \" + e.name\n            }),\n\n    // This child rule inherits from the previous one\n    rule('Subflow2H1')\n            .inheritsFrom(['Flowchart2H1'])\n            .in(\"e\", flowchartPk.Subflow)\n            .out(\"h1\", htmlPk.H1, {\n                // R.H.S. h1.value is inherited from the parent rule\n                // 'e' object is passed to the parent rule to calculate h1.value\n                h1.value = \"Subflow \" + h1.value\n            })\n])\n</code></pre> <p><code>isAbstract()</code> clause is used to define an abstract rule. The abstract rule contains an input element of type <code>Flowchart</code> and an output element of H1 heading. The output object's value is updated to the input object's name with a prefix \"Flowchart\". A new child rule that inherits from the abstract rule using the <code>inheritsFrom(['&lt;ruleNameList&gt;'])</code> clause. The child rule <code>Subflow2H1</code> has an input element of type <code>Subflow</code> which extends <code>Flowchart</code>. Its name is <code>e</code> just like in the parent rule, meaning when the child rule is executed the input object <code>e</code>  overrides the object <code>e</code> in the parent rule. The output element's type must be the same as the parent rule. The output object's value is \"Subflow \" followed by the value of <code>h1</code> in the abstract rule because both rules are executed and the output objects are calculated. Thus, the final output is an H1 element of the following format:</p> <pre><code>&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-yamtl.html#rule-override","title":"Rule Override","text":"<p>There may be cases where you need to override the output object of the parent rule. This means that when the rule that inherits is executed, the value of the output object in the parent rule is overridden by the value of the output object calculated in the child rule. This also means that the child output object has no value at the start of execution unlike when it is inherited with no override.</p> <pre><code>ruleStore([\n    rule('Flowchart2H1')\n        .in(\"e\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            //Assigns the name of the flowchart to the value of the h1 element\n            h1.value = \"Flowchart \" + e.name \n        }),\n\n    rule('Subflow2H1')\n        .inheritsFrom(['Flowchart2H1'])\n        .in(\"e\", flowchartPk.Subflow)\n        .out(\"h1\", htmlPk.H1, {\n\n            //If h1 value is inherited then it is not null, else it is null\n            if(h1.value !== null) {\n                //R.H.S h1.value is already calculated and inherited\n                h1.value = \"Subflow \" + h1.value\n            } else {\n                //h1 is newly initialised since rule is overridden\n                h1.value = \"Subflow \" + e.name //Overridden output object\n            }\n        //Override the parent rule so the child rule's h1 object is used    \n        }).overriding()\n        //Try out the above transformation without the overriding() method\n        //and see the difference in inheritance behaviour   \n])\n</code></pre> <p>To better understand the properties of the <code>overriding()</code> clause, you should see the difference in execution and output, when you use override and when you do not.</p> <p>When you use <code>overrding()</code>:</p> <p>The rule that inherits (<code>Subflow2H1</code>), overrides the parent rule's (<code>Flowchart2H1</code>) output object <code>h1</code> meaning its value is newly initialized (<code>null</code>), thus, the else-condition is invoked. The local input object <code>e</code> is referenced within the output block and its name (<code>e.name</code>) is retrieved to be assigned as part of a string to the value of <code>h1</code>. The output of this transformation would look like this:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Snoozing\"/&gt;\n</code></pre> <p>When you do not use <code>overriding()</code>:</p> <p>When the child rule is executed, the output element(s) of the parent rule is calculated first. This means that <code>h1</code> output object has a computed value in the parent rule. When you access the <code>h1</code> output object in the child rule, it references to the parent rule's <code>h1</code> output object (which contains a value). Thus, the if-condition is satisfied and the child rule's output object <code>h1</code> is assigned the value of a string and the value of <code>h1</code> object calculated within the parent rule. The main output of this transformation would be:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-yamtl.html#lazy-rules","title":"Lazy Rules","text":"<p>A lazy rule is a rule that is executed after all non-lazy rules. When multiple lazy rules are defined, then the lazy rules are invoked in sequential order.</p> <pre><code>ruleStore([\n    rule('Flowchart2Heading')\n        .in('f', flowchartPk.Flowchart)\n        .out('div', htmlPk.DIV, {\n            // without LAZY: div.children.addAll(fetch(f.nodes))\n            // with LAZY rules\n            div.children.addAll(fetch(f.nodes, 'out', 'NodeRule'))\n        }),\n    rule('NodeRule')\n        .isUniqueLazy()\n        .in(\"in\", flowchartPk.Node)\n        .out(\"out\", htmlPk.H1, {\n            out.value = in.name\n        }),\n    rule('Transition2H1')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", flowchartPk.H1, {\n            h1.value = t.name\n        })\n])\n</code></pre> <p>A <code>lazy</code> rule is called and not scheduled by the YAMTL engine, which may lead to different results each time the rule is executed. A <code>uniqueLazy</code> rule always outputs the same result no matter how many times it is invoked and executed. In the code snippet above, <code>Flowchart2Heading</code> rule adds some nodes to a <code>div</code> HTML block. The <code>div</code> adds children from another rule using a special <code>fetch</code> operation: <code>fetch(inputMatchedObject, outVarName, ruleName)</code>, where <code>inputMatchedObject</code> can be just a single value or a collection; <code>outVarName</code> is the name of the output object of the other rule which is being accessed; <code>ruleName</code> is the name of that other rule. In this example, <code>inputMatchedObject</code> is <code>f.nodes</code> which is a collection of <code>Node</code> objects found in the output object of the matched <code>NodeRule</code>. Since <code>NodeRule</code> has not been executed, the values of <code>div</code> are not populated just yet. Next, <code>NodeRule</code> is tagged as <code>uniqueLazy</code> so it is not executed and is skipped for now. <code>Transition2H1</code> rule transforms all <code>Transition</code> elements into <code>H1</code> headings, where the value of an <code>H1</code> element is the the name of the <code>Transition</code> passed to the input pattern. Now all non-lazy rules have been invoked so the <code>uniqueLazy</code> rule (<code>NodeRule</code>) can be executed next. All <code>Node</code> objects are transformed into <code>H1</code> HTML elements, where each <code>H1</code> output object's value is the name of the <code>Node</code> object it has been transformed from. This rule generates a collection of <code>H1</code> headings which can finally be passed to the special <code>fetch</code> operation of <code>Flowchart2Heading</code> rule. Thus, the <code>div</code> output object contains a collection of <code>H1</code> elements with names of <code>Node</code> objects as their values.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#transient-rules","title":"Transient Rules","text":"<p>Transient rules are rules whose output is not persisted in the target model. They are used to perform calculations and update objects in the target model. The transient clause is used to define a transient rule.</p> <pre><code>// an attribute shared among rules\ndef count = 0\n\nruleStore([\n    rule('Transitions2Div')\n        .isTransient()\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"div\", htmlPk.DIV, {\n            count++\n            println(count)\n        }),         \n    rule('FlowChart')\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = \"The ${f.name} flowchart has ${count} transitions\"\n                        .toString()\n        })\n])\n])\n</code></pre> <p>In the above example, the <code>Transitions2Div</code> rule is declared as transient. The <code>out</code> block is used to update the <code>count</code> variable with the number of children in the <code>div</code> output object, which happens automatically due to the number of transition elements (inputs) that match the rule. The <code>FlowChart</code> rule is not transient and it has an input object of type <code>Flowchart</code> and an output object of type <code>H1</code>. The value of the <code>H1</code> output object is a string that contains the name of the flowchart and the value of the <code>count</code> variable.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#rule-filtering","title":"Rule Filtering","text":"<p>In this example, a filter condition (which is a lambda expression) is applied to a rule to transform selected input objects.</p> <pre><code>ruleStore([\n    rule('SelectedTransitions2Text')\n        .in(\"t\", flowchartPk.Transition)\n        .filter{    \n            //Filter input objects that satify this condition\n            t.source.name == \"Is it really too early?\"      \n        }\n        .out(\"p\", htmlPk.P, {\n            p.value = t.name\n        })\n])\n</code></pre> <p>The rule <code>SelectedTransitions2Text</code> has an input element as a <code>Transition</code> object. A filter condition is applied to check the name of the transition's source. If the transition source name is \"Is it really too early?\" then only those input <code>Transition</code> objects will be transformed. The output element is an HTML paragraph element <code>p</code> whose value is updated to the name of the input <code>Transition</code> object.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#derived-input-elements","title":"Derived Input Elements","text":"<p>Derived elements are derived from input elements that have been matched in preceding input patterns of a rule. Here, the matching process is manually described instead of the automatic matching in matched elements.</p> <pre><code>ruleStore([\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .in(\"b\", flowchartPk.Action).derivedWith{ \n            def f = a.eContainer()\n            f.nodes.first()\n        }\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = b.name\n        })\n])\n</code></pre> <p>The rule <code>Action2Heading</code> contains an input object <code>b</code> that is derived from input object <code>a</code>'s first <code>Action</code> node. The output object <code>H1</code> is an HTML heading element with the value as the name of <code>b</code> input object. Note, that in the 'wakeup' flowchart model there are 4 <code>Action</code> elements so each of those is passed through the input patterns but since the <code>b</code> input object is derived from the first <code>Node</code> object of the <code>f</code> flowchart (<code>a</code>'s eContainer is the Flowchart object), the output will always be the name of the first node ('Wake up'). The result in the target model would look like this:</p> <pre><code>&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n</code></pre>"},{"location":"examples/flowchart-to-html-yamtl.html#multiple-sources","title":"Multiple Sources","text":"<p>If you want to transform multiple input objects into a single output object, you can do so by using the <code>in</code> clause multiple times. The input objects are matched in the order they are declared in the rule. Remember, the total number of input objects created is the cartesian product of the input objects of each input pattern. Usually, a filter is applied to the rule to ensure that the input objects are matched correctly and specifically chosen input objects are transformed.</p> <pre><code>ruleStore([\n    rule('SelectedTransitions2Text')\n        // This rule contains 3 input patterns\n        // Multiple sources create a cartesian product of output elements\n        // So filters are needed to avoid creating unwanted elements\n        .in(\"a\", flowchartPk.Action)\n        .filter {\n            // Filter out those actions that do not have outgoing transitions\n            !a.outgoing.isEmpty()\n        }\n        .in(\"d\", flowchartPk.Decision)\n        .in(\"t\", flowchartPk.Transition)\n        .filter{                        \n                // Only transform actions that match the input transition name\n                // OR\n                // decision elements that contain the input transition name\n                a.outgoing.name[0] == t.name || d.outgoing.name.contains(t.name)\n            }\n        .out(\"p\", htmlPk.P, {\n\n        // Create &lt;p&gt; elements with source, transition, and target info for action and decision elements\n        // Multiple duplicates of the decision element will be created showcasing the cartesian product behaviour\n            if(a.outgoing.name[0] == t.name) {\n                p.value = \"Source: ${a.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            } else if(d.outgoing.name[0] == t.name) {\n                p.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            } else if(d.outgoing.name[1] == t.name) {\n                p.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n            }\n        })\n])\n</code></pre> <p>In the above example, the rule <code>SelectedTransitions2Text</code> has 3 input objects: <code>a</code> of type <code>Action</code>, <code>d</code> of type <code>Decision</code> and <code>t</code> of type <code>Transition</code>. A filter is applied to the rule to ensure that the input objects are matched correctly. The filter condition checks if the <code>Action</code> object has an outgoing transition and if the name of the first outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Action</code> object, the name of the <code>Transition</code> object and the name of the target of the <code>Transition</code> object. If the second condition (regarding equivalent names) is not satisfied, then the filter condition checks if the <code>Decision</code> object has an outgoing transition and if the name of the outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object. If the condition is not satisfied, then the filter condition checks if the <code>Decision</code> object has a second outgoing transition and if the name of the second outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#mulitple-targets","title":"Mulitple Targets","text":"<p>If you want to transform a single input object into multiple output objects, you can do so by using the <code>out</code> clause multiple times. The output objects are created in the order they are declared in the rule.</p> <pre><code>ruleStore([\n    rule('Action2Elements')\n        // This rule has 1 input pattern and 3 output patterns\n        // All output objects are mapped to the same input object\n        .in(\"a\", flowchartPk.Action).filter { !a.outgoing.isEmpty() }\n        .out(\"title\", htmlPk.H1, {\n            title.value = a.name\n        })\n        .out(\"link\", htmlPk.A, {\n            link.value = \"Next steps\"\n            link.ahref = a.outgoing.first().target.name\n        })\n        .out(\"container\", htmlPk.DIV, {\n            // output vars of the rule can be referred directly\n            container.children.add(title)\n            container.children.add(link)\n        })\n])\n</code></pre> <p>In this scenario, there are 3 output objects: <code>title</code>, <code>link</code>, and <code>container</code>. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>a</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code> whose value is \"Next steps\" and the reference link is the name of the first outgoing transition's target. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The output of this transformation would look like this. The overall transformation converts <code>Action</code> elements into a <code>DIV</code> element that contains a <code>H1</code> element and an <code>A</code> element.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#to-many-operation","title":"To Many Operation","text":"<p>Matched rules can be declared with the modifier <code>toMany</code> that enables repeated rule application for the same input object subject to a valid termination condition <code>toManyCap</code> based on the match count. The argument passed to <code>toManyCap</code> is the number of output patterns in that rule. With <code>toMany</code> rules, the same rule may match the same object several times. In this case, we can refer to each (occurrence of a) match by the order in which they occurred: <code>fetch(inputMatchedObject, i)</code> will return the output object that was created by the <code>i</code>th match.</p> <p>When the output pattern consists of several object patterns, we need to specify the output object that we want to fetch: <code>fetch(inputMatchedObject, outVarName)</code> will return the output object corresponding to the output variable <code>outVarName</code>. If a matched rule with a complex output pattern is also declared as <code>toMany</code>, then we can retrieve the output object with the expression <code>fetch(inputMatchedObject, outVarName, i)</code>.</p> <pre><code>ruleStore([\n    rule('Action2Elements')\n        .toMany()\n        .toManyCap({2})\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"title\", htmlPk.H1, {\n            // The value will differ every time the rule is re-applied\n            title.value = d.name \n        })\n        .out(\"link\", htmlPk.A, {\n            // Access the current number of rule application\n            // using matchCount variable\n            if (matchCount == 0) {\n                link.name = \"Transition link 1\"\n                link.value = fetch(d, \"title\", 0).value\n                link.ahref = d.outgoing[0].name\n            } else {\n                link.name = \"Transition link 2\"\n                link.value = fetch(d, \"title\", 1).value\n                link.ahref =  d.outgoing[1].name\n            }\n        })\n        .out(\"container\", htmlPk.DIV, { \n            // Fetch the correct title and link for the current rule matching\n            container.value = \"Decision ${matchCount+1}\".toString()\n            container.children.add(fetch(d, \"title\", matchCount))\n            container.children.add(fetch(d, \"link\", matchCount))\n        })\n\n])\n</code></pre> <p>The above excerpt contains just one rule <code>Action2Elements</code> with one input pattern and multiple output patterns. <code>toManyCap({2})</code> means that the same rule is applied twice. This is useful to execute when the rule is needed to be executed multiple times to get different output or to get the same output multiple times. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>d</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code>. <code>matchCount</code> variable store the value of the current cycle of rule application, it is always between 0 and n (<code>toManyCap{n}</code>). In the first cycle of rule application, the <code>link</code> name, value (fetched from <code>title</code> object of the same cycle <code>0</code>) and the reference link (name of the first outgoing transition's name) is set. In the second cycle, we implement similar but different attributes to showcase the use of <code>matchCount</code>. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The corresponding value of the <code>i</code>th iteration of the rule application must be applied (in the third argument of <code>fetch()</code>), which is best set as <code>matchCount</code> variable. This means that in each cycle of rule execution, the title and link elements generated in that cycle are added to the container.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#end-with-block","title":"End With Block","text":"<p>If you want elements of a rule to interact with each other, you can do so at the end of a rule execution using an optional operation called <code>endWith</code>. An <code>endWith</code> block allows the user to group all elements of a rule, update objects and perform calculations using lamda expressions.</p> <pre><code>ruleStore([\n    rule('Flowchart2Body')\n        //Notice there is one source and multiple targets\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"b\", htmlPk.B, { \n            //Flowchart's name is turned into bold\n            b.value = f.name \n        })\n        .out(\"div\", htmlPk.DIV, {\n            //A div block contains all model transitions \n            div.children.addAll(f.transitions) \n        })\n        .out(\"body\", htmlPk.BODY, {\n            //All flowchart nodes are added to the body\n            body.children.addAll(f.nodes)\n        })//Last block of the transformation to be executed\n        .endWith({\n            //You can access the input object(s)\n            body.text = f.name\n\n            //Similarly, you can access all output object(s)\n            body.children.add(b) \n            body.children.add(div)\n    })\n])\n</code></pre> <p>In the transformation example above, one source element <code>f</code> is transformed into multiple targets: <code>b</code> is a <code>Bold</code> HTML element that is assigned the flowchart's name as its value, <code>div</code> output object has all transitions of the flowchart <code>f</code> as its children, and <code>body</code> output object has all flowchart <code>f</code> nodes as its children. Once, all output blocks are executed, the <code>endWith</code> block is invoked. In the <code>endWith</code> block, a lambda expression is defined that updates the <code>body</code> output object's text field with the <code>f</code> flowchart's name and the <code>body</code> object also adds new children: <code>b</code> output object and <code>div</code> output object. These updates are shown in the output, found in the target model.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#rule-priority","title":"Rule Priority","text":"<p>As the title suggests, you can prioritize rules to be executed in the order you prefer using the <code>priority(P)</code> clause where <code>P</code> is a whole number (e.g. 0, 1, 2,...) and the rules are executed in ascending values of <code>P</code> i.e. rules with lower <code>P</code> values have higher priority. </p> <pre><code>ruleStore([\n    //Run this rule first\n    rule('Flowchart2Title')\n        .priority(1)\n        .in(\"f\", flowchartPk.Flowchart)\n        .out(\"title\", htmlPk.TITLE, {\n            title.value = f.name \n        }),\n    //Run this third\n    rule('Action2Heading')\n        .priority(3)\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h2\", htmlPk.H2, {\n            h2.value = \"H2 heading for Action: \" + a.name\n        }),\n    //Run this rule second          \n    rule('Decision2Heading')\n        .priority(2)\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = \"H1 heading for Decision: \" + d.name \n        }),\n    //Finally run this rule\n    rule('Transition2Heading')\n        .priority(4)\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h3\", htmlPk.H3, {\n            h3.value = \"H3 heading for Transition: \" + t.name\n        })  \n])\n</code></pre> <p>In the MT definition above, the flow of execution for all the rules is:</p> <ol> <li><code>Flowchart2Title</code></li> <li><code>Decision2Heading</code></li> <li><code>Action2Heading</code></li> <li><code>Transition2Heading</code></li> </ol> <p>So you can expect the output of this transformation to also be ordered in the above manner within the target model.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#helpers","title":"Helpers","text":"<p>Helpers offer reusable expressions for rules. They can be used to define static attributes and operations, and contextual operations.</p> <ul> <li>A static attribute is a constant value that can be used in a rule. It is defined using the <code>staticAttribute('&lt;attributeName&gt;', { &lt;attributeValue&gt; })</code> clause. The attribute value can be a primitive value or an <code>EObject</code>. The attribute can be accessed in a rule using the <code>&lt;attributeName&gt;</code> variable. The power of this helper can be displayed using an allInstances(<code>EClass</code>) operation within the helper definition.</li> <li>A static operation is a static method which is defined for the class. It is defined using the <code>staticOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The operation body is a lambda expression that has a list of parameters specified as an arguments map (<code>argMap</code>) which must return a value.  The operation can be accessed in a rule using the <code>&lt;operationName&gt;</code> variable.</li> <li>A contextual operation is a bi-function that allows you to manipulate an argument object (could be an input or output object) and an argument map (which can be passed in between a rule and a helper). This a method invoked on a contextual instance of an object (first argument of the operation). It is defined using the <code>contextualOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The contextual operation body is a lambda expression that can contain two main arguments. The operation can be accessed in a rule using the <code>c_op</code> variable. The contextual operation is used to access the contextual instance of the input object and it must return either an <code>EObject</code> or a primitive value. The contextual instance is the input object that is matched in the input pattern of the rule. The contextual instance can be accessed in the operation body using the <code>obj</code> variable.</li> </ul> <pre><code>ruleStore([\n    rule('Action2Heading')\n        .in(\"a\", flowchartPk.Action)\n        .out(\"h1\", htmlPk.H1, {\n            h1.value = att.toString()\n        }),\n    rule('Decision2Heading')\n        .in(\"d\", flowchartPk.Decision)\n        .out(\"h1\", htmlPk.H1, {\n            //Call 'op' helper and pass the decision object as a key map\n            h1.value = op(['obj': d])\n        }),\n    rule('Transition2Heading')\n        .in(\"t\", flowchartPk.Transition)\n        .out(\"h1\", htmlPk.H1, {\n            //Call 'c_op' helper and pass the transition object as a key map\n            //Also pass a suffix increment argument to the contextual operation\n            h1.value = c_op(t, ['suffix': \"_${i++}\"])\n        })\n])\n\nhelperStore([\n    staticAttribute('att', { \n        def actionList = []\n        for (anAction in allInstances(flowchartPk.Action)) {\n            actionList.add(anAction.name)\n        }\n\n        //returns all instances of Action elements from the source model\n        return actionList\n    }),\n    staticOperation('op', { argsMap -&gt;\n        //returns the argument 'obj'\n        return argsMap.obj.name\n    }),\n    contextualOperation('c_op', { obj, argsMap -&gt;\n        //returns the name of the contextual instance 'obj' and argument 'suffix'\n        return obj.name + argsMap['suffix']\n    })\n])\n</code></pre> <p>In the example above, all flowchart elements are transformed into <code>H1</code> HTML headings. Within the <code>staticAttribute()</code> helper function, the <code>att</code> attribute returns a list of all instances of <code>Action</code> element in the source model. which is used in the <code>Action2Heading</code> rule. The <code>op</code> static operation returns the name of the <code>Decision</code> object <code>d</code> (passed as the value of a key map) which is used in the <code>Decision2Heading</code> rule. The <code>c_op</code> contextual operation returns the name of the <code>Transition</code> object appended by the value of the <code>suffix</code> argument (<code>i</code> increment counter) which is used in the <code>Transition2Heading</code> rule. This MT definition showcases all types of helpers and how they can be used in rules.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#model-queries","title":"Model Queries","text":"<p>A model query is a rule that has an input pattern and no output pattern. It may have an <code>endWith</code> block to report error messages or compute metrics. The <code>query()</code> clause is used to define a model query. The transformation definition for a model query would look like this:</p> <pre><code>ruleStore([\n    rule('Transition')\n        .in('t', flowchartPk.Transition)\n        .query()\n        .endWith{\n            println(\"processed successfully\")\n        }                \n    ])\n</code></pre> <p>Model queries require additional configuration when you execute the YAMTL module:</p> <pre><code>def mm = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore')\ndef query = new Query(mm.contents[0])\nYAMTLGroovyExtensions.init(this)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nquery.execute()\n</code></pre> <p>The <code>selectedExecutionPhases</code> variable is set to <code>MATCH_ONLY</code> to only execute the input pattern of the model query. The <code>loadInputModels()</code> function is used to load the input model. The <code>execute()</code> function is used to execute the model query. The <code>endWith</code> block is executed after the input pattern is matched which outputs a message to the console.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#module-composition","title":"Module Composition","text":"<p>You also have the capability to extend a YAMTL module by inheriting from it. This is called module composition. The <code>extends</code> clause is used to inherit from a YAMTL module. The transformation definition for module composition would look like this:</p> <pre><code>class ModuleComposition extends Inheritance {\n    public ModuleComposition(EPackage flowchartPk, EPackage htmlPk) {\n        super(flowchartPk, htmlPk)\n\n        ruleStore([\n            rule('Subflow2H1')\n                .inheritsFrom(['Flowchart2H1'])\n                .in(\"e\", flowchartPk.Subflow)\n                .out(\"h1\", htmlPk.H1, {\n                    h1.value = \"${h1.value}, where name of subflow is ${e.name}\"\n                                .toString()                         \n                })\n        ])\n}}\n</code></pre> <p><code>ModuleComposition</code> module extends the <code>Inheritance</code> module, which allows a rule to inherit from other rule(s) from a different module. The <code>inheritsFrom()</code> clause is used to inherit from a rule. The <code>Subflow2H1</code> rule inherits from the <code>Flowchart2H1</code> rule. The <code>h1</code> output object is updated to a string that contains the value of the <code>h1</code> output object from the <code>Flowchart2H1</code> rule and the name of the <code>Subflow</code> object <code>e</code>. The <code>ModuleComposition</code> module can be executed in the same way as the <code>Inheritance</code> module.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#transformation-test-script","title":"Transformation Test Script","text":"<p>The test script is responsible for loading source and target metamodels, initializing the MT definition, loading soure model into the transformation and executing it, and saving the output in the target model.</p> <pre><code>// model transformation execution\ndef srcRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore') \ndef tgtRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/html.ecore')\n\ndef xform = new &lt;groovyClass&gt;(srcRes.contents[0], tgtRes.contents[0])\nYAMTLGroovyExtensions.init(this)\nxform.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nxform.execute()\nxform.saveOutputModels(['out': BASE_PATH + '/&lt;outputFileName&gt;.xmi'])\n\n// test assertion\ndef actualModel = xform.getOutputModel('out')\nEMFComparator comparator = new EMFComparator();\n// Load the expected model using the identical output metamodel from the transformation.\n// Essentially, use the same in-memory metamodel.\nxform.loadMetamodelResource(tgtRes) \ndef expectedResource = xform.loadModel(BASE_PATH + '/&lt;expectedOutputFileName&gt;.xmi', false)\ndef assertionResult =  comparator.equals(expectedResource.getContents(), actualModel.getContents()) \nassertTrue(assertionResult);\n</code></pre> <p>First, both source and target metamodels are each loaded as a resource using a <code>YAMTLModule</code> function called <code>loadMetamodel(&lt;'projectPath'&gt;)</code>. <code>.ecore</code> files and their components are accessed using the <code>resourceName.contents[0]</code> clause. Note that <code>BASE_PATH</code> is just a global variable (with the value 'model' in this case) containing base directory name. <code>xform</code> variable initializes a new MT definition if a valid Groovy class name and parameters (source and target metamodels) are provided. Next, the input model is loaded using project path and the transformation is executed. The output is saved within the target model in the location (path) provided.</p> <p>The test assertion is performed using the <code>EMFComparator</code> package which compares the expected and actual output models. The expected model is loaded from the 'model' directory. The <code>assertionResult</code> variable is a boolean that is true if the expected and actual models are equal. The assertion is performed using the <code>assertTrue()</code> function. In case, the assertion fails, it means the project is not configured correctly or the transformation definition was changed to give a different output.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#development-platforms","title":"Development Platforms","text":"<p>Go to the YAMTL examples GitHub repository and clone it. The root directory is the base of all YAMTL example projects, and you will need to import this directory to configure and build the Gradle project.  You can import the project into an IDE of your choice. The following steps will provide details on how to set up the example project on Eclipse, IntelliJ, and VSCode.</p> <p>YAMTL uses Groovy scripts to define the models and transformations so generally any IDE will need some Groovy support through extensions/plug-ins. Make sure to have YAMTL correctly configured or do the necessary steps found in the YAMTL Workspace Configuration section before you run the project.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#eclipse","title":"Eclipse","text":"<p>In Eclipse, click on <code>File \u2192 Import \u2192 Existing Gradle Projects into Workspace \u2192 Select root directory of the Git repo \u2192 Finish</code>. This will import and load the project in the IDE.</p> <p>Head over to the <code>FlowchartToHTML</code> module within Eclipse, right-click on a test script of your choice in the <code>src/test/groovy</code> folder then <code>Run as \u2192 JUnit Test</code>. Once the test is completed, a new output file (XMI format) will be generated in the <code>model</code> directory. Examine this file.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#intellij","title":"IntelliJ","text":"<p>Within IntelliJ, go to <code>File \u2192 Open</code> and open the project at the root directory of the Git repository.</p> <p>Right-click on <code>src/test/groovy/flowchartToHtmlExamples</code> folder (within the <code>FlowchartToHTML</code> project directory), then 'Run Tests...'. </p> <p>Alternatively, click on the green run button in the top bar which builds the project and generates output files of all transformations in the <code>model</code> directory. </p>"},{"location":"examples/flowchart-to-html-yamtl.html#vscode","title":"VSCode","text":"<p>In VSCode, import the project at the root directory of the Git repository by doing <code>File \u2192 Open</code>.</p> <p>After you have imported the <code>FlowchartToHTML</code> project into the workspace, click on the Gradle icon in the left sidebar. Choose, the <code>FlowhchartToHTML</code> project and then perform <code>Tasks \u2192  build \u2192 clean</code>. Do <code>Tasks \u2192 build \u2192 build</code> to build the entire Gradle project (it also runs all test scripts that execute the transformations). </p> <p>Once the project is successfully built, all output files will be generated in the <code>model</code> directory. Examine these files.</p>"},{"location":"examples/flowchart-to-html-yamtl.html#references","title":"References","text":"<ul> <li>YAMTL Syntax</li> <li>YAMTL Incremental Support</li> <li>YAMTL Original Documentation</li> </ul>"},{"location":"examples/linked-list-reversal-example.html","title":"Linked List Reversal","text":""},{"location":"examples/linked-list-reversal-example.html#problem-description","title":"Problem Description","text":"<p>Let's see a simple example where a linked list with 2 nodes (N1 and N2) is reversed through model transformation.</p> <p>A linked list is a collection of sequentially connected nodes where each node contains some data and a reference (pointer) to the next node. The head of a linked list is the first node of the list i.e. the node that is not being referenced. The node at the end (tail) cannot point to the next node hence it references to <code>null</code>. A regular linked list comprises of these characteristics, so, we need to just change them appropriately to reverse the order of the nodes.</p> <p>Source Model</p> <p> </p> Linked list BEFORE transformation <p>Target Model</p> <p> </p> Linked list AFTER transformation <p></p> <p>You will need to understand this example's project structure before you read any line of code:</p> <p><pre><code>graph BT\n    B[Source Model] --&gt;|conforms to| A[Linked List Metamodel];\n    C[MT Execution Engine] --&gt;|reads| B;\n    C --&gt;|writes| D[Target Model];\n    C --&gt;|executes| E[MT Definition];\n    E --&gt;|uses| A;\n    D --&gt;|conforms to| A;</code></pre> </p> Dependencies of the project files"},{"location":"examples/linked-list-reversal-example.html#metamodel","title":"Metamodel","text":"<p>The source and target model must conform to the linked list metamodel. This contains the necessary information regarding the structure of the linked list at an abstract level such that certain characteristics of the linked list can still be changed in the model files. Look at the pseudocode below for the linked list metamodel:</p> Metamodel Pseudocode<pre><code>CLASS Linked List\n        SET reference to a Node object as HEAD\n        INIT LIST of Node objects\n\nCLASS Node\n        INIT string DATA attribute\n        SET reference to the NEXT Node object in the linked list \n</code></pre> <p>The metamodel contains two class definitions for <code>Linked List</code> and <code>Node</code> objects. The <code>Linked List</code> class has a <code>HEAD</code> attribute (as a reference) and a <code>LIST</code> of <code>Node</code> objects are initialised. The <code>Node</code> object contains a <code>DATA</code> field of the 'String' data type and a pointer (reference) to the <code>NEXT</code> object of the same type (<code>Node</code>) in the list.</p>"},{"location":"examples/linked-list-reversal-example.html#source-model","title":"Source Model","text":"<p>A sample source model (generally in XMI format) would look like the snippet below:</p> Sample Source Model in Flexmi<pre><code>&lt;LinkedList head=\"N1\"&gt;\n    &lt;node name=\"N1\" next=\"N2\"/&gt;\n    &lt;node name=\"N2\"/&gt;\n&lt;/LinkedList&gt;\n</code></pre>"},{"location":"examples/linked-list-reversal-example.html#target-model","title":"Target Model","text":"<p>A sample target model (also generally in XMI format) which is generated by performing a rule-based transformation on the source model would look like this:</p> Sample Target Model in Flexmi<pre><code>&lt;LinkedList head=\"N2\"&gt;\n    &lt;node name=\"N1\"/&gt;\n    &lt;node name=\"N2\" next=\"N1\"/&gt;\n&lt;/LinkedList&gt;\n</code></pre>"},{"location":"examples/linked-list-reversal-example.html#linked-list-reversal-yamtl-implementation","title":"Linked List Reversal - YAMTL Implementation","text":"<p>To demonstrate the YAMTL capabilities, let's look at a simple example that reverses a linked list using YAMTL. A linked list with 2 nodes (N1 and N2) is reversed through model transformation.</p> <p>Source Model</p> <p> </p> Linked list BEFORE transformation <p>Target Model</p> <p> </p> Linked list AFTER transformation <p></p> <p>There are 2 aspects of the linked list which are changed from the source model to the target model (thus requiring two tranformation rules): </p> <ol> <li>The head of the linked list is swapped with its tail. </li> <li>The nodes are reversed i.e. pointing to the previous node instead of the next one.</li> </ol>"},{"location":"examples/linked-list-reversal-example.html#yamtl-definition","title":"YAMTL Definition","text":"<p>The YAMTL definition is in a Groovy script as follows: </p> Snippet from ReverseLinkedList.groovy<pre><code>class ReverseLinkedList extends YAMTLModule {\n    public ReverseLinkedList(EPackage llPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n        header().in('in', llPk).out('out', llPk)\n\n        ruleStore([\n            rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes) //Mapping\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n        ])\n    }\n}\n</code></pre> <p>Let's understand each line of code to learn the YAMTL syntax and semantics.</p> <p>In Line 1, the class (also name of the file) extends <code>YAMTLModule</code> (which is imported) to highlight the code block containing YAMTL definition. In Line 2, the public method has an argument <code>llPk</code> (referring to linked list package) of the type <code>EPackage</code>. This adds EMF extensions to interpret getters/setters of an EObject and reference to classifiers inside an EPackage. Now, the classes in the <code>.emf</code> file can be accessed. In Line 3, the YAMTL Groovy Extensions for EMF import is initialised. In Line 4, the in and out parameters (of the source and target models respectively) for the model transformation is defined. In Line 6, the list of transformation rules is initialised using <code>ruleStore</code> operation. Each rule is contained here, separated by commas (,). In Line 7-9, the first rule <code>LinkedList2LinkedList</code> is created with the input source element 's' of the <code>Node</code> type accessed from the <code>llPk</code> package. The corresponding target element 't' is of the data type <code>Node</code> and the <code>out</code> operation also contains execution statements written in curly braces <code>{}</code>. In Line 10, nodes of the <code>LinkedList</code> 's' are all fetched and assigned to the target <code>LinkedList</code> element 't'. Here, the references or mappings of the nodes are passed to the target element. In Line 11, all <code>llPk.node</code>s are queried to find a <code>Node</code> object that does not reference or point to another <code>Node</code> object i.e. it points to <code>null</code>. The result of the <code>fetch</code> operation is assigned as the <code>head</code> attribute of the target element. Remember, this is one of the aspects discussed above, the head of the linked list is swapped with its tail. In Line 14-16, a new rule <code>Node2Node</code> is defined, its source element 's' and target element 't' have been initialised. Both elements are of the same type <code>Node</code> accessed via the <code>llPk</code> package. In Line 17, the source element's <code>name</code> attribute is assigned to the target element's <code>name</code> field. In Line 18, all <code>Node</code> objects in the source model are queried to find a <code>Node</code> object that has a <code>name</code> attribute which points/references to the source element 's'. The resultant <code>Node</code> object is fetched and assigned to the target element's <code>next</code> attribute. Recall, the second transformation aspect previously discussed, each node points to the previous node instead of the next one.</p>"},{"location":"examples/linked-list-reversal-example.html#transformation-test-script","title":"Transformation Test Script","text":"<p>Besides the actual transformation definition, you will also need a Groovy test script that automates the entire transformation process. Here, the relevant project files are configured and test assertions are implemented. Check out a snippet from the test script for the linked list reversal example below:</p> Snippet from ReverseLinkedListTest.groovy<pre><code>// model transformation execution example\ndef metamodel = YAMTLModule.loadMetamodel(BASE_PATH + '/LinkedList.ecore') as EPackage\ndef xform = new ReverseLinkedList(metamodel)\nxform.loadInputModels(['in': BASE_PATH + '/inputList.xmi'])\nxform.execute()\nxform.saveOutputModels(['out': BASE_PATH + '/outputList.xmi'])\n</code></pre> <p>The transformation is executed through a Gradle build run which also runs this test script. In the code snippet above, a groovy method contains the code for model transformation execution and tests assertion. First, the <code>metamodel</code> is loaded from a <code>.ecore</code> file as an <code>EPackage</code>. Then, <code>xform</code> initialises a new <code>ReverseLinkedList</code> transformation definition and passes the metamodel as an <code>EPackage</code> (<code>llPk</code> was a reference to the metamodel). The input parameter within the YAMTL definition script is set to be the relative location to the <code>inputList.xmi</code> file which contains the source model. This source model is loaded into the model transformation, the transformation rules are executed and the output model returned from <code>ReverseLinkedList()</code> is saved at a defined location through the output parameter. After the transformation is completed, some tests can be run to check the contents of the generated target model. The output model is compared against an expected output <code>expectedOutput.xmi</code> using <code>EMFComparator</code>.</p>"},{"location":"examples/linked-list-reversal-example.html#source-and-target-metamodel","title":"Source and Target Metamodel","text":"LinkedList.emf<pre><code>@namespace(uri=\"linkedlist\", prefix=\"\")\npackage linkedlist;\n\nclass LinkedList {\n    ref Node head;\n    val Node[*] nodes;\n}\n\nclass Node {\n    attr String name;\n    ref Node next;\n}\n</code></pre> <p>The Emfatic textual syntax is used to define the metamodel. The corresponding ECore file \"LinkedList.ecore\" can then be generated if the Emfatic software package is installed.</p>"},{"location":"examples/linked-list-reversal-example.html#source-model_1","title":"Source Model","text":"<p>Graphical Concrete Syntax</p> <p> </p> Linked list BEFORE transformation <p>XMI serialization of the Abstract Syntax inputList.xmi<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;LinkedList\n    xmi:version=\"2.0\"\n    xmlns:xmi=\"http://www.omg.org/XMI\"\n    xmlns=\"linkedlist\"\n    head=\"//@nodes.0\"&gt;\n    &lt;nodes name=\"N1\"\n        next=\"//@nodes.1\" /&gt;\n    &lt;nodes name=\"N2\" /&gt;\n&lt;/LinkedList&gt;\n</code></pre></p> <p>The source model conforms to the source metamodel (<code>LinkedList.emf</code>). The Groovy test script loads the source model, applies the transformation and saves the target model generated.</p>"},{"location":"examples/linked-list-reversal-example.html#target-model_1","title":"Target Model","text":"<p>Graphical Concrete Syntax</p> <p> </p> Linked list AFTER transformation <p>XMI serialization of the Abstract Syntax outputList.xmi<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;LinkedList\n  xmi:version=\"2.0\"\n  xmlns:xmi=\"http://www.omg.org/XMI\"\n  xmlns=\"linkedlist\"\n  head=\"//@nodes.1\"&gt;\n  &lt;nodes name=\"N1\" /&gt;\n  &lt;nodes name=\"N2\" next=\"//@nodes.0\" /&gt;\n&lt;/LinkedList&gt;\n</code></pre></p> <p>This is the output file you should expect when you correctly run the YAMTL program.</p>"},{"location":"examples/linked-list-reversal-example.html#development-platforms","title":"Development Platforms","text":"<p>Download the linked list reversal project (ZIP file). You can unzip and import the project into an IDE of your choice. This documentation will provide details on how to setup the example project on Eclipse, IntelliJ and VSCode.</p> <p>YAMTL uses groovy scripts to define the models and transformations so generally any IDE will need some Groovy support through extensions/plug-ins. Make sure to have YAMTL correctly configured or do the necessary steps found in the Choosing an IDE section before you run the project.</p>"},{"location":"examples/linked-list-reversal-example.html#eclipse","title":"Eclipse","text":"<p>Unzip the downloaded project. In Eclipse, click on <code>File \u2192 Import Gradle Project \u2192 Select root directory \u2192 Finish</code>. This will import and load the project in the IDE.</p> <p>Right click on <code>src/test/groovy/linkedListReversal/ReverseLinkedListTest.groovy</code> then <code>Run as \u2192 JUnit Test</code>. Once the test is completed, a new <code>outputList.xmi</code> will be generated in the <code>model</code> directory. Examine this file and notice if the linked list has been reversed.</p>"},{"location":"examples/linked-list-reversal-example.html#intellij","title":"IntelliJ","text":"<p>Within IntelliJ, go to <code>File \u2192 Open</code> and open the project.</p> <p>Right click on <code>src/test/groovy/linkedListReversal</code> folder then 'Run Tests...'. </p> <p>Alternatively, click on the green run button in the top bar to run <code>Tests in 'yamtl-linkedlistreversal'</code> which builds the project and generates an <code>outputList.xmi</code> in the <code>model</code> directory. </p> <p>Examine this file and notice if the linked list has been reversed.</p> <p></p>"},{"location":"examples/linked-list-reversal-example.html#vscode","title":"VSCode","text":"<p>In VSCode, import the project by doing <code>File \u2192 Open</code>.</p> <p>After you have imported the example project into the workspace, click on the Gradle icon in the left sidebar. Then perform <code>Tasks \u2192  build \u2192 clean</code>. Do <code>Tasks \u2192 build \u2192 build</code> to build the entire Gradle project (it also runs the <code>ReverseLinkedListTest.groovy</code> file). </p> <p></p> <p>Once the project is successfully built, an <code>outputList.xmi</code> will be generated in the <code>model</code> directory. Examine this file and notice if the linked list has been reversed.</p>"},{"location":"examples/linked-list-reversal-example.html#references","title":"References","text":"<ul> <li>YAMTL Syntax</li> <li>YAMTL Incremental Support</li> <li>YAMTL Original Documentation</li> </ul>"},{"location":"examples/multi-model-transformations.html","title":"Multi-Model Transformations","text":"<p>The code for the transformation below can be found here (<code>src/main/groovy/multimodel</code> contains the definition of transformations and <code>src/test/groovy/multimodel</code> how to execute them with some example models).</p> <p>The examples below use the metamodel <code>CD</code> of class diagrams below (in EMFatic notation):</p> <pre><code>package CD ;\n\nabstract class NamedElt {\n!ordered attr String[1] name;\n}\n\nabstract class Classifier extends NamedElt {\n}\n\nclass DataType extends Classifier {\n}\n\nclass Class extends Classifier {\n!ordered ref Class[*] ~super;\nval Attribute[*]#owner ~attr;\n!ordered attr Boolean[1] isAbstract = false;\n}\n\nclass Attribute extends NamedElt {\n!ordered attr Boolean[1] multiValued = false;\n!ordered ref Classifier[1] type;\n!ordered ref Class[1]#~attr owner;\n}\n\nclass Package extends Classifier {\nval Classifier[*] classifiers;\n}\n\ndatatype Boolean : java.lang.Boolean ;\n\ndatatype Integer : java.lang.Integer;\n\ndatatype String : java.lang.String;\n</code></pre>"},{"location":"examples/multi-model-transformations.html#constraints-across-input-domains-pattern-matching-semantics","title":"Constraints Across Input Domains (Pattern Matching Semantics)","text":"<p>Given the class diagram metamodel <code>CD</code> above, we can define a multi-model transformation that takes two class diagrams <code>model1</code> and <code>model2</code> (two instances of the metamodel <code>CD</code>) and checks whether <code>model1</code> is an embedding of <code>model2</code> (using the attribute <code>name</code> for identifying classes) as follows:</p> <pre><code>public class Embedding extends YAMTLModule {\n\n    def List&lt;String&gt; inconsistencyList = []\n\n    public Embedding(EPackage CD) {\n\n        YAMTLGroovyExtensions_dynamicEMF.init( this )\n\n        header().in('model1', CD).in('model2', CD)\n\n        ruleStore([\n            rule('Class')\n                .in('c1', 'model1', CD.Class)\n                    .filter { \n                        def c2 = allInstances('model2',CD.Class).find{ it.name == c1.name}\n                        c2 == null\n                    }\n                .query()\n                .endWith({\n                    inconsistencyList &lt;&lt; \"${c1.name} not in model2\"\n                })\n        ])\n    }   \n}\n</code></pre> <p>The input pattern in the transformation rule <code>Class</code> finds the classes <code>c1</code> in the domain <code>model1</code> that do not have a counterpart <code>c2</code> (with the same name) in <code>model2</code>. Hence, spotting inconsistencies. The block <code>endWith</code> is executed at the end of the rule application and appends the inconsistency to a list <code>inconsistencyList</code>.</p> <p>This transformation is executed with the following code, where we only use pattern matching semantics to apply the input pattern, without creating any output model:</p> <pre><code>def resSM = Embedding.preloadMetamodel(\"path/to/CD.ecore\")\ndef pk = resSM.contents.get(0) as EPackage\n\ndef embedding = new Embedding(pk)\nembedding.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nYAMTLGroovyExtensions.init( embedding )\n\nembedding.loadInputModels(['model1': 'path/to/model1.xmi', 'model2': 'path/to/model2.xmi'])\nembedding.execute()\n</code></pre>"},{"location":"examples/multi-model-transformations.html#model-matching-out-place-semantics","title":"Model Matching (Out-Place Semantics)","text":"<p>Given the class diagram metamodel <code>CD</code> above, we can define a multi-model transformation that checks the commonalities of two separate class diagrams as follows:</p> <pre><code>public class Comparator extends YAMTLModule {\n    public Comparator(EPackage CD) {\n        YAMTLGroovyExtensions_dynamicEMF.init( this )\n\n        header().in('model1', CD).in('model2', CD).out('out', CD)\n\n        ruleStore([\n            rule('MatchPackage')\n                .in('p1', 'model1', CD.Package)\n                .in('p2', 'model2', CD.Package).filter { p1.name == p2.name }\n                .out('new_p', 'out', CD.Package, {\n                    new_p.name = p1.name\n\n                    def new_c_list = fetch(['c1': p1.classifiers, 'c2': p2.classifiers])\n                    new_p.classifiers.addAll(new_c_list)\n                }),\n\n            rule('MatchDataType')\n                .in('c1', 'model1', CD.DataType)\n                .in('c2', 'model2', CD.DataType).filter { c1.name == c2.name }\n                .out('new_d', 'out', CD.DataType, {\n                    new_d.name = c1.name\n                }),\n\n            rule('MatchClass')\n                .in('c1', 'model1', CD.Class)\n                .in('c2', 'model2', CD.Class).filter { c1.name == c2.name }\n                .out('new_c', 'out', CD.Class, {\n                    new_c.name = c1.name\n                    def new_a_list = fetch(['a1': c1.attr, 'a2': c2.attr])\n                    new_c.attr.addAll(new_a_list)\n                }),\n\n            rule('MatchAttribute')\n                .in('a1', 'model1', CD.Attribute)\n                .in('a2', 'model2', CD.Attribute).filter { \n                    a1.owner.name == a2.owner.name &amp;&amp; a1.name == a2.name }\n                .out('new_a', 'out', CD.Attribute, {\n                    new_a.name = a1.name\n                })\n        ])\n    }\n}\n</code></pre> <p>Each rule in this transformation identifies common elements by type and name for the rules <code>MatchPackage</code>, <code>MatchDataType</code>, and <code>MatchClass</code>. The rule <code>MatchAttribute</code> additionally requires that the classes containing these attributes be matched as well.</p> <p>This transformation uses Out-Place Semantics to produce an output model with the common parts of two class diagrams, representing the match. Variants can be easily specified by using the <code>endWith</code> block or by including an additional <code>out</code> domain in the header to build an additional model.</p> <p>This example illustrates how the <code>fetch()</code> operator is used to find the output matches for a set of input matches. For example, <code>fetch(['c1': p1.classifiers, 'c2': p2.classifiers])</code> will return the list of objects that correspond to matches in <code>p1.classifiers</code> and <code>p2.classifiers</code> via the rules <code>MatchClass</code> and <code>MatchDataType</code>. YAMTL will automatically apply the rules internally and find the correct objects. Note that for this to work properly, the <code>in</code> elements must use the same variables, <code>c1</code> and <code>c2</code>, in both rules. This process can be simplified using rule inheritance by defining a super-rule that declares the common <code>in</code> element names.</p> <p>The transformation above is executed as a normal out-place transformation:</p> <pre><code>def matcher = new Comparator(pk)\nYAMTLGroovyExtensions.init( matcher )\n\nmatcher.loadInputModels(['model1': 'path/to/model1.xmi', 'model2': 'path/to/model2.xmi'])\nmatcher.execute()\nmatcher.saveOutputModels(['out': 'path/to/output.xmi'])\n</code></pre>"},{"location":"examples/query-dsl.html","title":"Model Queries atop YAMTL","text":"<p>Model queries in model-driven engineering applications are specialized queries designed to extract, manipulate, or analyze specific information from models that represent complex systems. These models, which may depict software architecture, business processes, or system behaviors, are central to the engineering process. Model queries enable developers to efficiently retrieve data, check model consistency, perform transformations, and validate system specifications against predefined criteria. By providing a mechanism to interact with models at a high level of abstraction, model queries facilitate automation, enhance accuracy, and improve the efficiency of model-driven development workflows.</p> <p>In this example, we introduce a QueryDsl to perform model queries atop YAMTL. For the example we are going to use a simple class diagram metamodel:</p> <pre><code>classDiagram\n    class NamedElt {\n        &lt;&lt;abstract&gt;&gt;\n        name: String\n    }\n    class Classifier {\n        &lt;&lt;abstract&gt;&gt;\n    }\n    class Package {\n    }\n    class Class {\n        isAbstract: Boolean = false\n    }\n    class Attribute {\n        multiValued: Boolean  = false\n    }\n    class DataType {\n    }\n    NamedElt &lt;|-- Classifier\n    NamedElt &lt;|-- Attribute\n    Classifier &lt;|-- Package\n    Classifier &lt;|-- DataType    \n    Classifier &lt;|-- Class\n    Class \"0..*\" --&gt; \"0..*\" Class : ~super\n    Class \"1\" *--&gt; \"0..*\" Attribute : ~attr\n    Attribute \"1\" --&gt; \"1\" Classifier : type\n    Package \"0..*\" *--&gt; \"0..*\" Classifier : classifiers</code></pre>"},{"location":"examples/query-dsl.html#model-queries","title":"Model Queries","text":"<p>The YAMTL QueryDsl is a Groovy DSL for evaluating model queries over EMF models. A model query is internally encoded as a match-only YAMTL model transformation that uses the YAMTL pattern matching semantics.</p> <p>A model query is defined using JSON-style syntax with Groovy closures as follows:</p> <pre><code>[\n    'context': '&lt;ContextType&gt;',\n    'where': '&lt;FilterClosure&gt;',\n    'query': '&lt;QueryClosure&gt;'\n]\n</code></pre> <p>where:</p> <ul> <li><code>&lt;ContextType&gt;</code> is a class name in the metamodel denoting the type for the contextual instances for the <code>where</code> and <code>query</code> clauses.</li> <li><code>&lt;FilterClosure&gt;</code> is a Groovy closure, whose parameter corresponds to an instance of the <code>&lt;ContextType&gt;</code>, specifying a boolean condition that must be satisfied by the contextual instance in order for the query to be evaluated. This parameter is optional, and when it is not specified, all contextual instances will be considered for the evaluation of the query.</li> <li><code>&lt;QueryClosure&gt;</code> is a Groovy closure, whose parameter corresponds to an instance of the <code>&lt;ContextType&gt;</code>, specifying a query. The query can be used to print some results in the output console or to gather information in variables.</li> </ul> <p>For example, the following query checks whether all classifiers within a package have unique names:</p> <pre><code>[\n    context: 'Package',\n    query: { \n        def idCounts = it.classifiers.countBy { it.name }\n        def repeatedIds = idCounts.findAll { k, v -&gt; v &gt; 1 }.keySet()\n        result = repeatedIds.size()\n    }\n]\n</code></pre> <p>In the example above, all classifiers within the selected package will be evaluated because a <code>where</code> clause has not been specified.</p> <p>The following example checks that class names are unique globally, not just within each package:</p> <pre><code>def classNamesSet = [] as Set&lt;String&gt;       \ndef queryDef = [\n    context: 'Class',\n    query: {\n        def added = classNamesSet.add(it.name)\n        if (!added) println(\"Error: ${it.name} is used for more than one class.\")\n    }\n]\n</code></pre> <p>The query above illustrates how to capture side effects in a global variable <code>classNamesSet</code>, declared outside of the query.</p> <p>The next example checks that all attributes within a particular class have unique names, for those classes with at least one attribute:</p> <pre><code>[\n    context: 'Class',\n    where: { it.attr.size() &gt; 0 },\n    query: {\n        def idCounts = it.attr.countBy { it.name }\n        def repeatedIds = idCounts.findAll { k, v -&gt; v &gt; 1 }.keySet()\n        result = repeatedIds.size()\n    }\n]\n</code></pre> <p>A model query is then executed using the <code>runQuery</code> command:</p> <pre><code>runQuery('path/to/metamodel.emf', 'path/to/model.xmi', query)\n</code></pre>"},{"location":"examples/query-dsl.html#translating-querydsl-into-yamtl","title":"Translating QueryDsl into YAMTL","text":"<p>Internally, a QueryDsl query is translated into a <code>YAMTLModule</code> where the <code>&lt;ContextType&gt;</code> and the <code>&lt;FilterClosure&gt;</code> are used to define a pattern in a YAMTL rule with a single input element, while the <code>&lt;QueryClosure&gt;</code> is used as a post-rule operation as follows:</p> <pre><code>class QueryActivityDsl extends YAMTLModule {\n\n    def EPackage activityPk\n\n    QueryActivityDsl(EPackage activityPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n        this.activityPk=activityPk\n        header().in('activity', activityPk)\n    }\n\n    void context(Map args) {\n        def context = args.context\n\n        if (!context) {\n            throw new RuntimeException(\"The context type needs to be given.\")\n        }\n        def where = args.where ?: { true }\n        def query = args.query ?: { println(self.toString()) }\n\n        ruleStore([\n            rule('Query')\n                .in('self', YAMTLGroovyExtensions_dynamicEMF.findEClass(activityPk, context))\n                .filter({ where.call(self) })\n                .query()\n                .endWith({ query.call(self) })\n        ])\n    }\n}\n</code></pre> <p>The code for the query DSL and example can be found here (<code>src/main/groovy/queryDsl</code> contains the definition of transformations and <code>src/test/groovy/queryDsl</code> how to execute them with some example models).</p>"},{"location":"exercises/flowchart-to-html-worksheet.html","title":"Flowchart to HTML","text":"<p>In this worksheet, we will look at converting flowchart elements into HTML elements to practice different elements of the YAMTL language.</p> <p>In the following subsections, you'll find:</p> <ul> <li>Source metamodel: to define workflows</li> <li>Source workflow model that we will use in most of the exercises</li> <li>Target metamodel: to define HTML documents</li> <li>Fill-in-the gap exercises</li> <li>Solutions: attempt the exercises first!</li> </ul> <pre><code>graph BT\n    B[Source Model] --&gt;|conforms to| A[Flowchart Metamodel];\n    C[YAMTL Engine] --&gt;|reads| B;\n    C --&gt;|executes| D[YAMTLModule];\n    C --&gt;|writes| E[Target Model];\n    D --&gt;|uses| A;\n    E --&gt;|conforms to| F[HTML Metamodel];\n    D --&gt;|uses| F;</code></pre> <p>These exercises can be solved interactively in the YAMTL playground.</p> <p>If you prefer to work with them in your IDE of choice, dowload the Gradle project from here.</p>"},{"location":"exercises/flowchart-to-html-worksheet.html#source-metamodel","title":"Source Metamodel","text":"<p>The source metamodel is defined using Emfatic (.emf), which can be converted into an <code>Ecore</code> file. You can then access the flowchart classes as <code>EPackage</code>s (<code>Ecore</code> has <code>EClasses</code> which are referenced as <code>EPackage</code> in Groovy) to be used within the MT definition. Let's view the class diagram and code implementation (in Emfatic) of the source metamodel representing the Flowchart domain.</p> <p></p> <p>The full metamodel can be read in Emfatic notation here.</p>"},{"location":"exercises/flowchart-to-html-worksheet.html#source-model","title":"Source Model","text":"<p>The flowchart that will be used as source model for most of the exercises is depicted in the diagram below:</p> <pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre>"},{"location":"exercises/flowchart-to-html-worksheet.html#target-metamodel","title":"Target Metamodel","text":"<p>Just like before, the target metamodel is also defined using Emfatic. The metamodel script is long because all HTML elements must be defined so that the transformation generates a valid HTML document. Let's check out the class diagram and code implementation (in Emfatic) of the target metamodel representing the HTML domain.</p> <p>The HTML metamodel is quite large to be viewed as one class diagram, so, let's see different sections of the metamodel for better understanding.</p> <p>HTML Section</p> <p></p> <p>HEADElement Section</p> <p></p> <p>BODYElement Section</p> <p>A lot of body related elements extend the BODYElement class. To show all of those elements the BODYElement section is further divided into 2 sub-sections with a diagram each.</p> <p>Sub-section 1: </p> <p>Sub-section 2: </p> <p>TABLEElement Section</p> <p></p> <p>LISTElement Section</p> <p></p> <p>Other Classes</p> <p></p> <p>The full metamodel can be read in Emfatic notation here.</p>"},{"location":"exercises/flowchart-to-html-worksheet.html#fill-the-gap-exercises","title":"Fill-the-Gap Exercises","text":"<p>These examples allow learners to practice the use of the YAMTL language at different levels of complexity: </p> <ul> <li>Exercise 1: creating an additional type of object in an output model within a rule.</li> <li>Exercise 2: specifying conditional application of rules.</li> <li>Exercise 3: practicing with rule inheritance.</li> <li>Exercise 4: defining several output elements in a rule to create a complex graph of objects in the output pattern.</li> <li>Exercise 5: using lazy and non-lazy rules.</li> <li>Exercise 6: using helpers.</li> </ul> <p>To solve these exercises interactively, go to the YAMTL playground.</p>"},{"location":"exercises/flowchart-to-html-worksheet.html#solutions","title":"Solutions","text":"<ul> <li>Exercise 1 - Solution</li> <li>Exercise 2 - Solution</li> <li>Exercise 3 - Solution</li> <li>Exercise 4 - Solution</li> <li>Exercise 5 - Solution</li> <li>Exercise 6 - Solution</li> </ul>"},{"location":"exercises/flowchart-to-html-worksheet.html#documentation","title":"Documentation","text":"<ul> <li>YAMTL reference language</li> </ul>"},{"location":"exercises-problems/exercise1.html","title":"Exercise 1","text":"<p>The main objective of this exercise is to convert the flowchart model\u2019s name into the name of a valid HEAD element (in HTML) i.e., the HEAD element is part of a valid HTML document.</p>"},{"location":"exercises-problems/exercise1.html#input-model","title":"Input Model","text":"<p>Source model representing the flowchart instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise1.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;HTML xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns=\"HTML\"&gt;\n  &lt;head value=\"Wakeup\"/&gt;\n&lt;/HTML&gt;\n</code></pre>"},{"location":"exercises-problems/exercise1.html#task","title":"Task","text":"<p>The base transformation below contains an input and output pattern. You must add another output pattern (.out) which has an object name \u201chtml\u201d and object type \u201cHTML\u201d. The lambda expression must set the \u2018head\u2019 attribute of the \u2018html\u2019 object as the object name \u2018head\u2019 (previously defined in the first output pattern).</p>"},{"location":"exercises-problems/exercise1.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\n\nimport org.eclipse.emf.ecore.EObject\nimport org.eclipse.emf.ecore.EPackage\n\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example1 extends YAMTLModule {\n    public Example1(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n                rule('FlowchartName2Head')\n                        .in(\"flowchart\", flowchartPk.Flowchart)\n                        .out(\"head\", htmlPk.HEAD, {             \n                            head.value = flowchart.name\n                        })\n                        //TODO: Add another output object here\n\n        ])\n\n    }\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-problems/exercise2.html","title":"Exercise 2","text":"<p>The main task of this exercise is to convert selective transition elements (of the flowchart model) into P tags (in HTML).</p>"},{"location":"exercises-problems/exercise2.html#input-model","title":"Input Model","text":"<p>Source model representing the flowchart instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise2.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;xmi:XMI xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns=\"HTML\"&gt;\n  &lt;P value=\"Node: Is it really too early? --&gt; Transition: Yes\"/&gt;\n  &lt;P value=\"Node: Is it really too early? --&gt; Transition: No\"/&gt;\n&lt;/xmi:XMI&gt;\n</code></pre>"},{"location":"exercises-problems/exercise2.html#task","title":"Task","text":"<p>You must create a filter block that checks if the name of the source node of the transition object \u2018t\u2019 is \u201cIs it really too early?\u201d. Only those transitions that pass this check are filtered through to be generated as output elements in the target model.</p>"},{"location":"exercises-problems/exercise2.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example2 extends YAMTLModule {\n    public Example2(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //TODO: Update the rule with a .filter{} block\n            rule('SelectedTransitions2Text')\n                .in(\"t\", flowchartPk.Transition)\n                .out(\"p\", htmlPk.P, {\n                    p.value = \"Node: ${t.source.name} --&gt; Transition: ${t.name}\".toString()\n                })\n        ])\n\n    }\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-problems/exercise3.html","title":"Exercise 3","text":"<p>Here, you will have to showcase the concept of inheritance in YAMTL using an abstract parent rule and a concrete child rule. In particular, you must create a H1 heading whose value is the culmination of two rules: parent rule and child rule.</p>"},{"location":"exercises-problems/exercise3.html#new-input-model","title":"New Input Model","text":"<p>Unlike the previous examples, we will use a new flowchart model that contains subflow element (i.e. flowchart within a flowchart). We will now consider a section of the original flowchart to be a subflow flowchart (named 'Snoozing') with its own implementation of nodes and transitions.</p> <p></p> <p>Source model representing the flowchart with subflow instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Subflow\" xmi:id=\"_BYIhADZzEeOvH6AlutIRRw\" name=\"Snoozing\"&gt;\n    &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;/nodes&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise3.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;H1 xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns=\"HTML\" value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"exercises-problems/exercise3.html#task","title":"Task","text":"<p>Inherit the parent rule, to access its implementation and output the combined result of both parent and child rules. The requirements for this problem can be separated into implementing the parent rule and the child rule.</p> <p>Parent Rule</p> <p>Define a new rule \u2018Flowchart2H1\u2019 and annotate it as abstract. Create one input object \u2018f\u2019 of the type \u2018Flowchart\u2019 and one output object \u2018h1\u2019 of the type \u2018H1\u2019. Set the value of the h1 output object to be a concatenated string of \u201cFlowchart \u201d and the name of \u2018f\u2019 input object.</p> <p>Child Rule</p> <p>Define the next rule as \u2018Subflow2H1\u2019 and add the tag inheritsFrom which requires a list of rule names as an argument e.g., <code>inheritsFrom([&lt;ruleNameList&gt;])</code>. The only rule we want the child rule to inherit is \u2018Flowchart2H1\u2019. Create an input object \u2018f\u2019 of the type \u2018Subflow\u2019. Remember, rules that inherit from another rule must have the same output object name and type. If they also have the same input names then you can pass child input object to the parent rule. Thus, define an output pattern with the same name and type as the one in the parent rule. Instead of just accessing the implementation of the parent rule, we can extend the functionality of the child rule by adding a lambda expression that sets the value of \u2018h1\u2019 output object as the concatenated string of  \u201cSubflow \u201d and value of \u2018h1\u2019 again. Note that the second definition of h1 object inherits the implementation of the parent rule. This means, the subflow name is passed to the output pattern of the parent rule and the h1.value is calculated. This result is then passed to the output pattern of the child rule so the final value of h1 would be \u2018Subflow Flowchart Snoozing\u2019.</p>"},{"location":"exercises-problems/exercise3.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example3 extends YAMTLModule {\n    public Example3(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //This parent rule is abstract, so it will not be applied directly\n            //but it can be executed by its children\n            rule('Flowchart2H1')\n                //TODO: Implement the parent rule here\n\n            //This child rule inherits from the previous one\n            rule('Subflow2H1')\n                //TODO: Implement the child rule here\n\n        ])\n\n    }\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-problems/exercise4.html","title":"Exercise 4","text":"<p>This task involves the use of fetching matched output objects from other rules. This is done using the YAMTL fetch() operation.</p>"},{"location":"exercises-problems/exercise4.html#input-model","title":"Input Model","text":"<p>Source model representing the flowchart instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise4.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;TABLE xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"HTML\"&gt;\n  &lt;trs&gt;\n    &lt;tds xsi:type=\"TH\" value=\"Node\"/&gt;\n    &lt;tds xsi:type=\"TH\" value=\"Incoming Transition(s)\"/&gt;\n    &lt;tds xsi:type=\"TH\" value=\"Outgoing Transition(s)\"/&gt;\n  &lt;/trs&gt;\n  &lt;trs&gt;\n    &lt;tds value=\"Wake up\"/&gt;\n    &lt;tds value=\"[Some Time Passes, start]\"/&gt;\n    &lt;tds value=\"[]\"/&gt;\n  &lt;/trs&gt;\n  &lt;trs&gt;\n    &lt;tds value=\"Is it really too early?\"/&gt;\n    &lt;tds value=\"[]\"/&gt;\n    &lt;tds value=\"[Yes, No]\"/&gt;\n  &lt;/trs&gt;\n  &lt;trs&gt;\n    &lt;tds value=\"Sleep\"/&gt;\n    &lt;tds value=\"[Yes]\"/&gt;\n    &lt;tds value=\"[Some Time Passes]\"/&gt;\n  &lt;/trs&gt;\n  &lt;trs&gt;\n    &lt;tds value=\"Get up\"/&gt;\n    &lt;tds value=\"[No]\"/&gt;\n    &lt;tds value=\"[]\"/&gt;\n  &lt;/trs&gt;\n  &lt;trs&gt;\n    &lt;tds value=\"begin\"/&gt;\n    &lt;tds value=\"[]\"/&gt;\n    &lt;tds value=\"[start]\"/&gt;\n  &lt;/trs&gt;\n&lt;/TABLE&gt;\n</code></pre>"},{"location":"exercises-problems/exercise4.html#task","title":"Task","text":"<p>A partial solution for the transformation of Node elements into Table form is made available (as seen in the base transformation code). You must understand the hints given in the single line comments to implement a line of code for each comment. Complete all the lines to be able to run and view the target model. Refer to the target metamodel (html.emf) to find attributes of TR and TABLE elements. </p> <p>HINT: the syntax for fetch operation in this example is <code>fetch(&lt;inputMatchedObject&gt;, \u201c&lt;outputObject&gt;\u201d)</code> where <code>&lt;inputMatchedObject&gt;</code> is all nodes of the flowchart and <code>\u201c&lt;outputObject&gt;\u201d</code> is the name of the output object in double quotes. Also, remember that you use a Groovy inbuilt function to add an object.</p>"},{"location":"exercises-problems/exercise4.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example4 extends YAMTLModule {\n    public Example4(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            rule('Node2TableRows')\n                .in(\"n\", flowchartPk.Node)\n                .out(\"name\", htmlPk.TD, {\n                    name.value = n.name \n                })\n                .out(\"from\", htmlPk.TD, {\n                    from.value = n.incoming.name.toString()\n                })\n                .out(\"to\", htmlPk.TD, { \n                    to.value = n.outgoing.name.toString()\n                })\n                .out(\"tr\", htmlPk.TR, {\n                    //TODO: Add name object to 1st column\n\n                    //TODO: Add from object to 2nd column\n\n                    //TODO: Add to object to 3rd column\n\n                }),\n            rule('Flowchart2Table')\n                .in(\"f\", flowchartPk.Flowchart)\n                .out(\"headingName\", htmlPk.TH, {\n                    headingName.value = \"Node\"\n                })\n                .out(\"headingIncoming\", htmlPk.TH, {\n                    headingIncoming.value = \"Incoming Transition(s)\"\n                })\n                .out(\"headingOutgoing\", htmlPk.TH, {\n                    headingOutgoing.value = \"Outgoing Transition(s)\"\n                })\n                .out(\"headingRow\", htmlPk.TR, {\n                    //TODO: Add headingName object to 1st column\n\n                    //TODO: Add headingIncoming object to 2nd column\n\n                    //TODO: Add headingOutgoing object to 3rd column\n\n                })\n                .out(\"table\", htmlPk.TABLE, {\n                    //TODO: Add heading row\n\n                    //TODO: Add all table rows using fetch operation\n\n                })\n        ]) \n    }\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-problems/exercise5.html","title":"Exercise 5","text":"<p>For this task, you will need to implement a model transformation definition containing a lazy rule.</p>"},{"location":"exercises-problems/exercise5.html#input-model","title":"Input Model","text":"<p>Source model representing the flowchart instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise5.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;DIV xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"HTML\"&gt;\n  &lt;children xsi:type=\"H1\" value=\"Wake up\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"Is it really too early?\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"Sleep\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"Get up\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"begin\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"Yes\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"Some Time Passes\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"No\"/&gt;\n  &lt;children xsi:type=\"H1\" value=\"start\"/&gt;\n&lt;/DIV&gt;\n</code></pre>"},{"location":"exercises-problems/exercise5.html#task","title":"Task","text":"<p>Within the skeleton version of the base transformation script provided below, you must create a lazy rule, non-lazy rule, another rule that fetches the outputs of the first two rules.</p> <ol> <li>Define a lazy rule \u2018Node2H1\u2019 with an input object \u2018in\u2019 of the type \u2018Node\u2019 and an output object \u2018out\u2019 of the type \u2018H1\u2019. The \u2018out\u2019 object\u2019s value should be set to the name of \u2018in\u2019 object.</li> <li>Define a regular rule \u2018Transition2H1\u2019 with an input object \u2018t\u2019 of the type \u2018Transition\u2019 and an output object \u2018h1\u2019 of the type \u2018H1\u2019. Set the value of h1 to be the name of \u2018t\u2019.</li> <li>Create a final rule \u2018Flowchart2DIV\u2019. It must have an input object \u2018f\u2019 with the \u2018Flowchart\u2019 type. The output object\u2019s name should be \u2018div\u2019 and of the type \u2018DIV\u2019. We will add all transformed nodes and transitions objects into a \u2018DIV\u2019 block. So, access the \u2018div\u2019 object\u2019s children attribute and perform the function <code>addAll()</code> to add multiple nodes into the \u2018div\u2019 block. Remember, lazy rules are only invoked if they are called using a fetch operation from another rule and in this case, it must be defined as an argument to <code>addAll()</code> function. Thus, we will use the operation <code>fetch(&lt;inputMatchedObject&gt;, &lt;outputObject&gt;, &lt;ruleName&gt;)</code> where <code>&lt;inputMatchedObject&gt;</code> is the flowchart nodes i.e., <code>f.nodes</code>, <code>&lt;outputObject&gt;</code> is the name of the output object to be added to the \u2018div\u2019 block and <code>&lt;ruleName&gt;</code> is the name of the rule containing <code>&lt;outputObject&gt;</code>. Unlike lazy rules, you do not need a verbose fetch operation for non-lazy rules. Create another <code>div.children.addAll()</code> in the lambda expression of the \u2018div\u2019 output object and use the function <code>fetch(&lt;inputMatchedObject&gt;)</code> whose argument would be all transitions of flowchart \u2018f\u2019 (i.e. f.transitions).</li> </ol> <p>Once you have completed all the steps you can run the Groovy script. In the target model, you will notice that all node and transition elements are transformed into <code>H1</code> headings and are part of a <code>DIV</code> block.</p>"},{"location":"exercises-problems/exercise5.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules must be defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example5 extends YAMTLModule {\n    public Example5(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //TODO: Create a lazy rule\n\n            //TODO: Create a non-lazy/regular rule\n\n            //TODO: Create a rule that fetches the outputs of the first two rules\n        ])\n\n    }\n\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-problems/exercise6.html","title":"Exercise 6","text":"<p>In the final task of this tutorial, we will look at various types of helper functions in YAMTL and use such functions to provide additional capabilties to model transformations.</p>"},{"location":"exercises-problems/exercise6.html#input-model","title":"Input Model","text":"<p>Source model representing the flowchart instance (in XMI format) conforming to the flowchart domain is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"exercises-problems/exercise6.html#expected-output-model","title":"Expected Output Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;xmi:XMI xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns=\"HTML\"&gt;\n  &lt;H1 value=\"[Wake up, Sleep, Get up, begin]\"/&gt;\n  &lt;H1 value=\"[Wake up, Sleep, Get up, begin]\"/&gt;\n  &lt;H1 value=\"[Wake up, Sleep, Get up, begin]\"/&gt;\n  &lt;H1 value=\"[Wake up, Sleep, Get up, begin]\"/&gt;\n  &lt;H1 value=\"[Sleep, Get up]\"/&gt;\n  &lt;H1 value=\"1. \"/&gt;\n  &lt;H1 value=\"2. Yes\"/&gt;\n  &lt;H1 value=\"3. Some Time Passes\"/&gt;\n  &lt;H1 value=\"4. No\"/&gt;\n  &lt;H1 value=\"5. start\"/&gt;\n&lt;/xmi:XMI&gt;\n</code></pre>"},{"location":"exercises-problems/exercise6.html#task","title":"Task","text":"<p>A transformation script containing <code>staticAttribute</code> and <code>staticOperation</code> helper types has already been defined in the base transformation. Check out those helper functions and write the final helper type called <code>contextualOperation</code> that takes in two arguments: an object and an argument map, then returns the concatenation of the arguments map object's string value and the first argument object's name. Use this <code>contextualOperation</code> to create reusable function that appends an increment counter prefix to the name of the input object. Let's see how this can be done.</p> <p>In <code>Transition2Heading</code> rule, set the value of <code>h1</code> object to a function call <code>c_op()</code> (the returned value will be set as the h1.value). <code>c_op(&lt;object&gt;, [&lt;listOfArgumentMap&gt;])</code> contains an <code>&lt;object&gt;</code> (in this case we need to pass the input object 't') and <code>[&lt;listOfArgumentMap&gt;]</code> (this has one key 'prefix' and a value as the increment counter <code>i</code>).</p> <p>Create a new contextual operation helper function as <code>contextualOperation('&lt;operationName&gt;', {obj, argsMapExpression})</code> within the <code>helperStore()</code>. <code>&lt;operationName&gt;</code> is the name of the operation that you want to define i.e. <code>c_op</code>. <code>obj</code> is the first argument passed into the function call within the <code>Transition2Heading</code> rule. <code>argsMapExpression</code> is a lambda expression as seen in the <code>staticOperation</code> before. You only need to define a single statement that returns the concatenation of the value of the key 'prefix' (which was passed into <code>argsMap</code> as a key-value pair before) and the name of the <code>obj</code> object.</p> <p>That's all! Let's summarise the steps we did before. To set the value of <code>h1</code> object of <code>Transition2Heading</code>, we called a helper function <code>c_op</code> and passed the input <code>Transition</code> object 't' and a list of arguments map with one key-value pair (specifically a variable <code>i</code> was provided to the function). Then we defined the contextual operation helper that returns the concatenated string of the calculation made with both arguments <code>obj</code> and map value. Remember, this function is reusable in any other rule which could lead to efficient code. </p>"},{"location":"exercises-problems/exercise6.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\n\nimport static yamtl.dsl.Helper.*\nimport static yamtl.dsl.Rule.*\n\nimport org.eclipse.emf.ecore.EClass\nimport org.eclipse.emf.ecore.EPackage\n\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example6 extends YAMTLModule {\n    public int i = 1\n\n    public Example6(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in('in', flowchartPk).out('out', htmlPk)\n\n        ruleStore([\n            rule('Action2Heading')\n                    .in(\"a\", flowchartPk.Action)\n                    .out(\"h1\", htmlPk.H1, {                 \n                        h1.value = att.toString()\n                    }),\n            rule('Decision2Heading')\n                    .in(\"d\", flowchartPk.Decision)\n                    .out(\"h1\", htmlPk.H1, {\n                        h1.value = op(['obj': d])\n                    }),\n            rule('Transition2Heading')\n                    .in(\"t\", flowchartPk.Transition)\n                    .out(\"h1\", htmlPk.H1, {\n                        //TODO: Set value of h1 as the value returned from contextual operation\n\n                    }) \n        ])\n\n        helperStore([\n            staticAttribute('att', {                \n                def actionList = []\n                for (anAction in allInstances(flowchartPk.Action)) {\n                    actionList.add(anAction.name)\n                }\n\n                //returns all instances of Action elements from the source model\n                return actionList\n            }),\n            staticOperation('op', { argsMap -&gt;\n                def aTransition = (flowchartPk.Transition as EClass)\n                aTransition = argsMap.obj.outgoing\n\n                //The name of the target node of the outgoing transition from 'd' Decision element\n                return aTransition.target.name.toString()\n            }),\n            //TODO: Create a contextualOperation helper function that has 2 parameters\n\n\n\n\n        ])\n\n    }\n}\n</code></pre> <p>To solve this exercises interactively, go to the YAMTL playground.</p> <p>A downloadable solution can be found here.</p>"},{"location":"exercises-solutions/solution1.html","title":"Exercise 1 - Implementation","text":""},{"location":"exercises-solutions/solution1.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\n\nimport org.eclipse.emf.ecore.EObject\nimport org.eclipse.emf.ecore.EPackage\n\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example1 extends YAMTLModule {\n    public Example1(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n                rule('FlowchartName2Head')\n                        .in(\"flowchart\", flowchartPk.Flowchart)\n                        .out(\"head\", htmlPk.HEAD, {             \n                            head.value = flowchart.name\n                        })\n                        //TODO: Add another output object here\n\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution1.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example1 extends YAMTLModule {\n    public Example1(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n                rule('FlowchartName2Head')\n                        .in(\"flowchart\", flowchartPk.Flowchart)\n                        .out(\"head\", htmlPk.HEAD, {             \n                            head.value = flowchart.name\n                        })\n                        .out(\"html\", htmlPk.HTML, {\n                            html.head = head \n                        }),\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution2.html","title":"Exercise 2 - Implementation","text":""},{"location":"exercises-solutions/solution2.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example2 extends YAMTLModule {\n    public Example2(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //TODO: Update the rule with a .filter{} block\n            rule('SelectedTransitions2Text')\n                .in(\"t\", flowchartPk.Transition)\n                .out(\"p\", htmlPk.P, {\n                    p.value = \"Node: ${t.source.name} --&gt; Transition: ${t.name}\".toString()\n                })\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution2.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example2 extends YAMTLModule {\n    public Example2(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n\n\n        ruleStore([\n            rule('SelectedTransitions2Text')\n                .in(\"t\", flowchartPk.Transition)\n                .filter{\n                    //Only transform those transitions\n                    //that satisfy the following condition\n                    t.source.name == \"Is it really too early?\"\n\n                }\n                .out(\"p\", htmlPk.P, {\n                    p.value = \"Node: ${t.source.name} --&gt; Transition: ${t.name}\".toString()\n                })\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution3.html","title":"Exercise 3 - Implementation","text":""},{"location":"exercises-solutions/solution3.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example3 extends YAMTLModule {\n    public Example3(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //This parent rule is abstract, so it will not be applied directly\n            //but it can be executed by its children\n            rule('Flowchart2H1')\n                //TODO: Implement the parent rule here\n\n            //This child rule inherits from the previous one\n            rule('Subflow2H1')\n                //TODO: Implement the child rule here\n\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution3.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example3 extends YAMTLModule {\n    public Example3(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //This parent rule is abstract, so it will not be applied directly\n            //but it can be executed by its children\n            rule('Flowchart2H1')\n                .isAbstract()\n                .in(\"f\", flowchartPk.Flowchart)\n                .out(\"h1\", htmlPk.H1, {\n                    h1.value = \"Flowchart \" + f.name\n                }),\n\n            //This child rule inherits from the previous one\n            rule('Subflow2H1')\n                .inheritsFrom(['Flowchart2H1'])\n                .in(\"f\", flowchartPk.Subflow)\n                .out(\"h1\", htmlPk.H1, {\n                    //r.h.s h1.value is inherited from the parent rule\n                    //'e' object is passed to the parent rule to calculate h1.value\n                    h1.value = \"Subflow \" + h1.value\n                })\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution4.html","title":"Exercise 4 - Implementation","text":""},{"location":"exercises-solutions/solution4.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example4 extends YAMTLModule {\n    public Example4(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            rule('Node2TableRows')\n                .in(\"n\", flowchartPk.Node)\n                .out(\"name\", htmlPk.TD, {\n                    name.value = n.name \n                })\n                .out(\"from\", htmlPk.TD, {\n                    from.value = n.incoming.name.toString()\n                })\n                .out(\"to\", htmlPk.TD, { \n                    to.value = n.outgoing.name.toString()\n                })\n                .out(\"tr\", htmlPk.TR, {\n                    //TODO: Add name object to 1st column\n\n                    //TODO: Add from object to 2nd column\n\n                    //TODO: Add to object to 3rd column\n\n                }),\n            rule('Flowchart2Table')\n                .in(\"f\", flowchartPk.Flowchart)\n                .out(\"headingName\", htmlPk.TH, {\n                    headingName.value = \"Node\"\n                })\n                .out(\"headingIncoming\", htmlPk.TH, {\n                    headingIncoming.value = \"Incoming Transition(s)\"\n                })\n                .out(\"headingOutgoing\", htmlPk.TH, {\n                    headingOutgoing.value = \"Outgoing Transition(s)\"\n                })\n                .out(\"headingRow\", htmlPk.TR, {\n                    //TODO: Add headingName object to 1st column\n\n                    //TODO: Add headingIncoming object to 2nd column\n\n                    //TODO: Add headingOutgoing object to 3rd column\n\n                })\n                .out(\"table\", htmlPk.TABLE, {\n                    //TODO: Add heading row\n\n                    //TODO: Add all table rows using fetch operation\n\n                })\n        ]) \n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution4.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example4 extends YAMTLModule {\n    public Example4(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            rule('Node2TableRows')\n                .in(\"n\", flowchartPk.Node)\n                .out(\"name\", htmlPk.TD, {\n                    name.value = n.name \n                })\n                .out(\"from\", htmlPk.TD, {\n                    from.value = n.incoming.name.toString()\n                })\n                .out(\"to\", htmlPk.TD, { \n                    to.value = n.outgoing.name.toString()\n                })\n                .out(\"tr\", htmlPk.TR, {\n                    //Add name object to 1st column\n                    tr.tds.add(name)\n                    //Add from object to 2nd column\n                    tr.tds.add(from)\n                    //Add to object to 3rd column\n                    tr.tds.add(to)\n                }),\n            rule('Flowchart2Table')\n                .in(\"f\", flowchartPk.Flowchart)\n                .out(\"headingName\", htmlPk.TH, {\n                    headingName.value = \"Node\"\n                })\n                .out(\"headingIncoming\", htmlPk.TH, {\n                    headingIncoming.value = \"Incoming Transition(s)\"\n                })\n                .out(\"headingOutgoing\", htmlPk.TH, {\n                    headingOutgoing.value = \"Outgoing Transition(s)\"\n                })\n                .out(\"headingRow\", htmlPk.TR, {\n                    //Add headingName object to 1st column\n                    headingRow.tds.add(headingName)\n                    //Add headingIncoming object to 2nd column\n                    headingRow.tds.add(headingIncoming)\n                    //Add headingOutgoing object to 3rd column\n                    headingRow.tds.add(headingOutgoing)\n                })\n                .out(\"table\", htmlPk.TABLE, {\n                    //Add heading row\n                    table.trs.add(headingRow)\n                    //Add all table rows using fetch operation\n                    table.trs.addAll(fetch(f.nodes, \"tr\"))\n                })\n        ]) \n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution5.html","title":"Exercise 5 - Implementation","text":""},{"location":"exercises-solutions/solution5.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules must be defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example5 extends YAMTLModule {\n    public Example5(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            //TODO: Create a lazy rule\n\n            //TODO: Create a non-lazy/regular rule\n\n            //TODO: Create a rule that fetches the outputs of the first two rules\n        ])\n\n    }\n\n}\n</code></pre>"},{"location":"exercises-solutions/solution5.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\nimport static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example5 extends YAMTLModule {\n    public Example5(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in(\"in\", flowchartPk).out(\"out\", htmlPk)\n\n        ruleStore([\n            rule('Node2H1')\n                .isLazy()\n                .in(\"in\", flowchartPk.Node) \n                .out(\"out\", htmlPk.H1, {\n                    out.value = in.name\n                }),\n            rule('Transition2H1')\n                .in(\"t\", flowchartPk.Transition)\n                .out(\"h1\", htmlPk.H1, {\n                    h1.value = t.name\n                }),\n            rule('Flowchart2DIV')\n                .in('f', flowchartPk.Flowchart)\n                .out('div', htmlPk.DIV, {\n                    // without LAZY: div.children.addAll(fetch(f.nodes))\n                    // with LAZY rules\n                    div.children.addAll(fetch(f.nodes, 'out', 'Node2H1'))\n                    div.children.addAll(fetch(f.transitions))\n                }),\n\n        ])\n\n    }\n\n}\n</code></pre>"},{"location":"exercises-solutions/solution6.html","title":"Exercise 6 - Implementation","text":""},{"location":"exercises-solutions/solution6.html#base-transformation","title":"Base Transformation","text":"<p>Transformation class containing the MT definition. All rules are defined in the <code>ruleStore()</code>.</p> <pre><code>package flowchartToHtmlExamples\n\nimport static yamtl.dsl.Helper.*\nimport static yamtl.dsl.Rule.*\n\nimport org.eclipse.emf.ecore.EClass\nimport org.eclipse.emf.ecore.EPackage\n\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example6 extends YAMTLModule {\n    public int i = 1\n\n    public Example6(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in('in', flowchartPk).out('out', htmlPk)\n\n        ruleStore([\n            rule('Action2Heading')\n                    .in(\"a\", flowchartPk.Action)\n                    .out(\"h1\", htmlPk.H1, {                 \n                        h1.value = att.toString()\n                    }),\n            rule('Decision2Heading')\n                    .in(\"d\", flowchartPk.Decision)\n                    .out(\"h1\", htmlPk.H1, {\n                        h1.value = op(['obj': d])\n                    }),\n            rule('Transition2Heading')\n                    .in(\"t\", flowchartPk.Transition)\n                    .out(\"h1\", htmlPk.H1, {\n                        //TODO: Set value of h1 as the value returned from contextual operation\n\n                    }) \n        ])\n\n        helperStore([\n            staticAttribute('att', {                \n                def actionList = []\n                for (anAction in allInstances(flowchartPk.Action)) {\n                    actionList.add(anAction.name)\n                }\n\n                //returns all instances of Action elements from the source model\n                return actionList\n            }),\n            staticOperation('op', { argsMap -&gt;\n                def aTransition = (flowchartPk.Transition as EClass)\n                aTransition = argsMap.obj.outgoing\n\n                //The name of the target node of the outgoing transition from 'd' Decision element\n                return aTransition.target.name.toString()\n            }),\n            //TODO: Create a contextualOperation helper function that has 2 parameters\n\n\n\n\n        ])\n\n    }\n}\n</code></pre>"},{"location":"exercises-solutions/solution6.html#solution","title":"Solution","text":"<p>The correct transformation definition for this problem is:</p> <pre><code>package flowchartToHtmlExamples\n\nimport static yamtl.dsl.Helper.*\nimport static yamtl.dsl.Rule.*\n\nimport org.eclipse.emf.ecore.EClass\nimport org.eclipse.emf.ecore.EPackage\n\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass Example6 extends YAMTLModule {\n    public int i = 1\n\n    public Example6(EPackage flowchartPk, EPackage htmlPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in('in', flowchartPk).out('out', htmlPk)\n\n        ruleStore([\n            rule('Action2Heading')\n                    .in(\"a\", flowchartPk.Action)\n                    .out(\"h1\", htmlPk.H1, {                 \n                        h1.value = att.toString()\n                    }),\n            rule('Decision2Heading')\n                    .in(\"d\", flowchartPk.Decision)\n                    .out(\"h1\", htmlPk.H1, {\n                        h1.value = op(['obj': d])\n                    }),\n            rule('Transition2Heading')\n                    .in(\"t\", flowchartPk.Transition)\n                    .out(\"h1\", htmlPk.H1, {\n                        h1.value = c_op(t, ['prefix': \"${i++}. \"])\n                    }) \n        ])\n\n        helperStore([\n            staticAttribute('att', {                \n                def actionList = []\n                for (anAction in allInstances(flowchartPk.Action)) {\n                    actionList.add(anAction.name)\n                }\n\n                //returns all instances of Action elements from the source model\n                return actionList\n            }),\n            staticOperation('op', { argsMap -&gt;\n                def aTransition = (flowchartPk.Transition as EClass)\n                aTransition = argsMap.obj.outgoing\n\n                //The name of the target node of the outgoing transition from 'd' Decision element\n                return aTransition.target.name.toString()\n            }),\n            contextualOperation('c_op', { obj, argsMap -&gt;\n                //returns the name of the contextual instance 'obj' and argument 'suffix'\n                return argsMap['prefix'].toString() + obj.name\n            })\n        ])\n\n    }\n}\n</code></pre>"}]}